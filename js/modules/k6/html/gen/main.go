package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type ElemInfo struct ***REMOVED***
	ConstName     string
	StructName    string
	PrtStructName string
***REMOVED***

type FuncDef struct ***REMOVED***
	ElemName     string
	PropertyName string
	ReturnType   string
***REMOVED***

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct ***REMOVED***
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
***REMOVED***

var attrFuncDefs = []string***REMOVED***
	"Href Rel string",
	"Area Href string",
	"Area AccessKey bool",
	"Base Autofocus string",
	"Button AccessKey string",
	"Button Autofocus string",
	"Button Disabled string",
***REMOVED***

func main() ***REMOVED***
	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, "elements.go", nil, 0)

	if err != nil ***REMOVED***
		log.Fatalf("warning: internal error: could not parse elemts.go: %s", err)
		return
	***REMOVED***

	ce := &CollectElements***REMOVED******REMOVED***
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool ***REMOVED***
		if n != nil ***REMOVED***
			ce.handler = ce.handler(n)
		***REMOVED***
		return true
	***REMOVED***)

	f, err := os.Create("elements_gen.go")
	if err != nil ***REMOVED***
		log.Println("warning: internal error: invalid Go generated:", err)
	***REMOVED***
	elemsTemplate.Execute(f, struct ***REMOVED***
		ElemInfos    map[string]*ElemInfo
		AttrFuncDefs []string
	***REMOVED******REMOVED***
		ce.elemInfos,
		attrFuncDefs,
	***REMOVED***)
	f.Close()
***REMOVED***

var elemsTemplate = template.Must(template.New("").Funcs(template.FuncMap***REMOVED***
	"buildStruct":   buildStruct,
	"splitFuncDef":  splitFuncDef,
	"buildFuncBody": buildFuncBody,
	"toLower":       strings.ToLower,
***REMOVED***).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html
func selToElement(sel Selection) goja.Value ***REMOVED***
	if sel.sel.Length() == 0 ***REMOVED***
		return goja.Undefined()
	***REMOVED***

	elem := Element***REMOVED***sel.sel.Nodes[0], &sel***REMOVED***
	
	switch elem.node.Data ***REMOVED*** ***REMOVED******REMOVED*** range $elemInfo := .ElemInfos ***REMOVED******REMOVED*** 
	case ***REMOVED******REMOVED*** $elemInfo.ConstName ***REMOVED******REMOVED***:
		return sel.rt.ToValue(***REMOVED******REMOVED*** buildStruct $elemInfo ***REMOVED******REMOVED***)
	***REMOVED******REMOVED*** end ***REMOVED******REMOVED*** 
	default:
		return sel.rt.ToValue(elem)
	***REMOVED***
***REMOVED***

***REMOVED******REMOVED*** range $funcDefStr := .AttrFuncDefs ***REMOVED******REMOVED*** ***REMOVED******REMOVED*** $funcDef := splitFuncDef $funcDefStr ***REMOVED******REMOVED***
func (e ***REMOVED******REMOVED***$funcDef.ElemName***REMOVED******REMOVED***Element) ***REMOVED******REMOVED***$funcDef.PropertyName***REMOVED******REMOVED***() ***REMOVED******REMOVED***$funcDef.ReturnType***REMOVED******REMOVED*** ***REMOVED***
	return e.***REMOVED******REMOVED*** buildFuncBody $funcDef ***REMOVED******REMOVED***("***REMOVED******REMOVED*** toLower $funcDef.PropertyName ***REMOVED******REMOVED***")
***REMOVED***
***REMOVED******REMOVED*** end ***REMOVED******REMOVED***
`))

// Build fragments for the template
func buildStruct(elemInfo ElemInfo) string ***REMOVED***
	if elemInfo.PrtStructName == "Element" ***REMOVED***
		return elemInfo.StructName + "***REMOVED***elem***REMOVED***"
	***REMOVED*** else ***REMOVED***
		return elemInfo.StructName + "***REMOVED***" + elemInfo.PrtStructName + "***REMOVED***elem***REMOVED******REMOVED***"
	***REMOVED***
***REMOVED***

func splitFuncDef(funcDef string) FuncDef ***REMOVED***
	parts := strings.Split(funcDef, " ")
	return FuncDef***REMOVED***parts[0], parts[1], parts[2]***REMOVED***
***REMOVED***

func buildFuncBody(funcDef FuncDef) string ***REMOVED***
	switch funcDef.ReturnType ***REMOVED***
	case "string":
		return `attrAsString`

	case "bool":
		return `attrIsPresent`

	default:
		panic("Unknown attrType in a funcDef")
	***REMOVED***
***REMOVED***

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler ***REMOVED***
	ce.elemName = ""

	switch node.(type) ***REMOVED***
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler ***REMOVED***
	switch x := node.(type) ***REMOVED***
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") ***REMOVED***
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo***REMOVED***x.Name, "", ""***REMOVED***
		***REMOVED***

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler ***REMOVED***
	switch x := node.(type) ***REMOVED***
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") ***REMOVED***
			return ce.defaultHandler
		***REMOVED***

		if ce.elemName == "" ***REMOVED***
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok ***REMOVED***
				return ce.defaultHandler
			***REMOVED***

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		***REMOVED*** else ***REMOVED***
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		***REMOVED***

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***
