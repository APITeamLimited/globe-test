package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type ElemInfo struct ***REMOVED***
	ConstName     string
	StructName    string
	PrtStructName string
***REMOVED***

type FuncDef struct ***REMOVED***
	ElemName   string
	ElemMethod string
	AttrMethod string
	AttrArg    string
	ReturnType string
***REMOVED***

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct ***REMOVED***
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
***REMOVED***

var attrFuncDefs = []string***REMOVED***
	"Href Rel string",
	"Href Href string",
	"Href ToString=href string",
	"Base Autofocus bool",
	"Button AccessKey string",
	"Button Autofocus string",
	"Button Disabled string",
***REMOVED***

var testFuncDefs = []string***REMOVED***
	//Element MethodToTest AttrName=AttrVal
	"Anchor Rel relattrval",
	"Anchor Href hrefattrval",
	"Anchor ToString href=hrefval",
	"Base Autofocus true",
	"Button AccessKey q",
	"Button Autofocus true",
	"Button Disabled string",
***REMOVED***

func main() ***REMOVED***
	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, "elements.go", nil, 0)

	if err != nil ***REMOVED***
		log.Fatalf("warning: internal error: could not parse elemts.go: %s", err)
		return
	***REMOVED***

	ce := &CollectElements***REMOVED******REMOVED***
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool ***REMOVED***
		if n != nil ***REMOVED***
			ce.handler = ce.handler(n)
		***REMOVED***
		return true
	***REMOVED***)

	f, err := os.Create("elements_gen.go")
	if err != nil ***REMOVED***
		log.Println("warning: internal error: invalid Go generated:", err)
	***REMOVED***
	elemsTemplate.Execute(f, struct ***REMOVED***
		ElemInfos    map[string]*ElemInfo
		AttrFuncDefs []string
	***REMOVED******REMOVED***
		ce.elemInfos,
		attrFuncDefs,
	***REMOVED***)
	f.Close()
***REMOVED***

var elemsTemplate = template.Must(template.New("").Funcs(template.FuncMap***REMOVED***
	"buildStruct":  buildStruct,
	"buildFuncDef": buildFuncDef,
***REMOVED***).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

func selToElement(sel Selection) goja.Value ***REMOVED***
	if sel.sel.Length() == 0 ***REMOVED***
		return goja.Undefined()
	***REMOVED***

	elem := Element***REMOVED***sel.sel.Nodes[0], &sel***REMOVED***
	
	switch elem.node.Data ***REMOVED*** ***REMOVED******REMOVED*** range $elemInfo := .ElemInfos ***REMOVED******REMOVED*** 
	case ***REMOVED******REMOVED*** $elemInfo.ConstName ***REMOVED******REMOVED***:
		return sel.rt.ToValue(***REMOVED******REMOVED*** buildStruct $elemInfo ***REMOVED******REMOVED***)
	***REMOVED******REMOVED*** end ***REMOVED******REMOVED*** 
	default:
		return sel.rt.ToValue(elem)
	***REMOVED***
***REMOVED***

***REMOVED******REMOVED*** range $funcDefStr := .AttrFuncDefs ***REMOVED******REMOVED*** ***REMOVED******REMOVED*** $funcDef := buildFuncDef $funcDefStr ***REMOVED******REMOVED***
func (e ***REMOVED******REMOVED***$funcDef.ElemName***REMOVED******REMOVED***) ***REMOVED******REMOVED***$funcDef.ElemMethod***REMOVED******REMOVED***() ***REMOVED******REMOVED***$funcDef.ReturnType***REMOVED******REMOVED*** ***REMOVED***
	return e.***REMOVED******REMOVED*** $funcDef.AttrMethod ***REMOVED******REMOVED***("***REMOVED******REMOVED*** $funcDef.AttrArg ***REMOVED******REMOVED***")
***REMOVED***
***REMOVED******REMOVED*** end ***REMOVED******REMOVED***
`))

// Build fragments for the template
func buildStruct(elemInfo ElemInfo) string ***REMOVED***
	if elemInfo.PrtStructName == "Element" ***REMOVED***
		return elemInfo.StructName + "***REMOVED***elem***REMOVED***"
	***REMOVED*** else ***REMOVED***
		return elemInfo.StructName + "***REMOVED***" + elemInfo.PrtStructName + "***REMOVED***elem***REMOVED******REMOVED***"
	***REMOVED***
***REMOVED***

func buildFuncDef(funcDef string) FuncDef ***REMOVED***
	parts := strings.Split(funcDef, " ")
	// parts[0] is the element struct name (without the Element suffix for brevity)
	// parts[1] is either:
	//   MethodName               The TitleCased name of method to add onto that struct.
	//                            The string is lowercased and given as an argment to elem.attrAsString(...) or elem.AttrIsPresent(...)
	//   MethodName=attrname      The MethodName is the name of the mehtid to add to the struct. The attrname is given, as is, to attrAsString ot AttrIsPresent
	// parts[2] is return type, either string or bool
	elemName := parts[0] + "Element"
	elemMethod := parts[1]
	attrName := strings.ToLower(parts[1])
	returnType := parts[2]

	if eqPos := strings.Index(parts[1], "="); eqPos != -1 ***REMOVED***
		attrName = elemMethod[eqPos+1:]
		elemMethod = elemMethod[0:eqPos]
	***REMOVED***

	switch returnType ***REMOVED***
	case "string":
		// "Button AccessKey string" => ***REMOVED***"ButtonElement" "AccessKey", "attrIsString", "accesskey", "string"***REMOVED*** => `func (e ButtonElement) AccessKey() string***REMOVED*** return e.attrAsString("accessKey") ***REMOVED***``
		// "Href ToString=href string" => ***REMOVED***"HrefElement" "ToString", "attrIsString", "href", "string"***REMOVED*** => `func (e HrefElement) ToString() string ***REMOVED*** return e.textContent("href") ***REMOVED***``
		return FuncDef***REMOVED***elemName, elemMethod, "attrAsString", attrName, returnType***REMOVED***
	case "bool":
		// "Button Autofocus bool" ***REMOVED***"Button" "Autofocus", "attrIsPresent", "autofocus", "bool"***REMOVED*** => `func (e ButtonElement) ToString() bool ***REMOVED*** return e.attrIsPresent("autofocus") ***REMOVED***``
		return FuncDef***REMOVED***elemName, elemMethod, "attrIsPresent", attrName, returnType***REMOVED***
	default:
		panic("Unknown attrType in a funcDef")
	***REMOVED***
***REMOVED***

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler ***REMOVED***
	ce.elemName = ""

	switch node.(type) ***REMOVED***
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler ***REMOVED***
	switch x := node.(type) ***REMOVED***
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") ***REMOVED***
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo***REMOVED***x.Name, "", ""***REMOVED***
		***REMOVED***

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler ***REMOVED***
	switch x := node.(type) ***REMOVED***
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") ***REMOVED***
			return ce.defaultHandler
		***REMOVED***

		if ce.elemName == "" ***REMOVED***
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok ***REMOVED***
				return ce.defaultHandler
			***REMOVED***

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		***REMOVED*** else ***REMOVED***
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		***REMOVED***

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	***REMOVED***
***REMOVED***
