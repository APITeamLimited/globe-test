// Copyright (C) MongoDB, Inc. 2017-present.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

package bsoncodec

import (
	"encoding"
	"fmt"
	"reflect"
	"strconv"

	"go.mongodb.org/mongo-driver/bson/bsonoptions"
	"go.mongodb.org/mongo-driver/bson/bsonrw"
	"go.mongodb.org/mongo-driver/bson/bsontype"
)

var defaultMapCodec = NewMapCodec()

// MapCodec is the Codec used for map values.
type MapCodec struct ***REMOVED***
	DecodeZerosMap         bool
	EncodeNilAsEmpty       bool
	EncodeKeysWithStringer bool
***REMOVED***

var _ ValueCodec = &MapCodec***REMOVED******REMOVED***

// KeyMarshaler is the interface implemented by an object that can marshal itself into a string key.
// This applies to types used as map keys and is similar to encoding.TextMarshaler.
type KeyMarshaler interface ***REMOVED***
	MarshalKey() (key string, err error)
***REMOVED***

// KeyUnmarshaler is the interface implemented by an object that can unmarshal a string representation
// of itself. This applies to types used as map keys and is similar to encoding.TextUnmarshaler.
//
// UnmarshalKey must be able to decode the form generated by MarshalKey.
// UnmarshalKey must copy the text if it wishes to retain the text
// after returning.
type KeyUnmarshaler interface ***REMOVED***
	UnmarshalKey(key string) error
***REMOVED***

// NewMapCodec returns a MapCodec with options opts.
func NewMapCodec(opts ...*bsonoptions.MapCodecOptions) *MapCodec ***REMOVED***
	mapOpt := bsonoptions.MergeMapCodecOptions(opts...)

	codec := MapCodec***REMOVED******REMOVED***
	if mapOpt.DecodeZerosMap != nil ***REMOVED***
		codec.DecodeZerosMap = *mapOpt.DecodeZerosMap
	***REMOVED***
	if mapOpt.EncodeNilAsEmpty != nil ***REMOVED***
		codec.EncodeNilAsEmpty = *mapOpt.EncodeNilAsEmpty
	***REMOVED***
	if mapOpt.EncodeKeysWithStringer != nil ***REMOVED***
		codec.EncodeKeysWithStringer = *mapOpt.EncodeKeysWithStringer
	***REMOVED***
	return &codec
***REMOVED***

// EncodeValue is the ValueEncoder for map[*]* types.
func (mc *MapCodec) EncodeValue(ec EncodeContext, vw bsonrw.ValueWriter, val reflect.Value) error ***REMOVED***
	if !val.IsValid() || val.Kind() != reflect.Map ***REMOVED***
		return ValueEncoderError***REMOVED***Name: "MapEncodeValue", Kinds: []reflect.Kind***REMOVED***reflect.Map***REMOVED***, Received: val***REMOVED***
	***REMOVED***

	if val.IsNil() && !mc.EncodeNilAsEmpty ***REMOVED***
		// If we have a nil map but we can't WriteNull, that means we're probably trying to encode
		// to a TopLevel document. We can't currently tell if this is what actually happened, but if
		// there's a deeper underlying problem, the error will also be returned from WriteDocument,
		// so just continue. The operations on a map reflection value are valid, so we can call
		// MapKeys within mapEncodeValue without a problem.
		err := vw.WriteNull()
		if err == nil ***REMOVED***
			return nil
		***REMOVED***
	***REMOVED***

	dw, err := vw.WriteDocument()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	return mc.mapEncodeValue(ec, dw, val, nil)
***REMOVED***

// mapEncodeValue handles encoding of the values of a map. The collisionFn returns
// true if the provided key exists, this is mainly used for inline maps in the
// struct codec.
func (mc *MapCodec) mapEncodeValue(ec EncodeContext, dw bsonrw.DocumentWriter, val reflect.Value, collisionFn func(string) bool) error ***REMOVED***

	elemType := val.Type().Elem()
	encoder, err := ec.LookupEncoder(elemType)
	if err != nil && elemType.Kind() != reflect.Interface ***REMOVED***
		return err
	***REMOVED***

	keys := val.MapKeys()
	for _, key := range keys ***REMOVED***
		keyStr, err := mc.encodeKey(key)
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		if collisionFn != nil && collisionFn(keyStr) ***REMOVED***
			return fmt.Errorf("Key %s of inlined map conflicts with a struct field name", key)
		***REMOVED***

		currEncoder, currVal, lookupErr := defaultValueEncoders.lookupElementEncoder(ec, encoder, val.MapIndex(key))
		if lookupErr != nil && lookupErr != errInvalidValue ***REMOVED***
			return lookupErr
		***REMOVED***

		vw, err := dw.WriteDocumentElement(keyStr)
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		if lookupErr == errInvalidValue ***REMOVED***
			err = vw.WriteNull()
			if err != nil ***REMOVED***
				return err
			***REMOVED***
			continue
		***REMOVED***

		err = currEncoder.EncodeValue(ec, vw, currVal)
		if err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***

	return dw.WriteDocumentEnd()
***REMOVED***

// DecodeValue is the ValueDecoder for map[string/decimal]* types.
func (mc *MapCodec) DecodeValue(dc DecodeContext, vr bsonrw.ValueReader, val reflect.Value) error ***REMOVED***
	if val.Kind() != reflect.Map || (!val.CanSet() && val.IsNil()) ***REMOVED***
		return ValueDecoderError***REMOVED***Name: "MapDecodeValue", Kinds: []reflect.Kind***REMOVED***reflect.Map***REMOVED***, Received: val***REMOVED***
	***REMOVED***

	switch vrType := vr.Type(); vrType ***REMOVED***
	case bsontype.Type(0), bsontype.EmbeddedDocument:
	case bsontype.Null:
		val.Set(reflect.Zero(val.Type()))
		return vr.ReadNull()
	case bsontype.Undefined:
		val.Set(reflect.Zero(val.Type()))
		return vr.ReadUndefined()
	default:
		return fmt.Errorf("cannot decode %v into a %s", vrType, val.Type())
	***REMOVED***

	dr, err := vr.ReadDocument()
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	if val.IsNil() ***REMOVED***
		val.Set(reflect.MakeMap(val.Type()))
	***REMOVED***

	if val.Len() > 0 && mc.DecodeZerosMap ***REMOVED***
		clearMap(val)
	***REMOVED***

	eType := val.Type().Elem()
	decoder, err := dc.LookupDecoder(eType)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	eTypeDecoder, _ := decoder.(typeDecoder)

	if eType == tEmpty ***REMOVED***
		dc.Ancestor = val.Type()
	***REMOVED***

	keyType := val.Type().Key()

	for ***REMOVED***
		key, vr, err := dr.ReadElement()
		if err == bsonrw.ErrEOD ***REMOVED***
			break
		***REMOVED***
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		k, err := mc.decodeKey(key, keyType)
		if err != nil ***REMOVED***
			return err
		***REMOVED***

		elem, err := decodeTypeOrValueWithInfo(decoder, eTypeDecoder, dc, vr, eType, true)
		if err != nil ***REMOVED***
			return newDecodeError(key, err)
		***REMOVED***

		val.SetMapIndex(k, elem)
	***REMOVED***
	return nil
***REMOVED***

func clearMap(m reflect.Value) ***REMOVED***
	var none reflect.Value
	for _, k := range m.MapKeys() ***REMOVED***
		m.SetMapIndex(k, none)
	***REMOVED***
***REMOVED***

func (mc *MapCodec) encodeKey(val reflect.Value) (string, error) ***REMOVED***
	if mc.EncodeKeysWithStringer ***REMOVED***
		return fmt.Sprint(val), nil
	***REMOVED***

	// keys of any string type are used directly
	if val.Kind() == reflect.String ***REMOVED***
		return val.String(), nil
	***REMOVED***
	// KeyMarshalers are marshaled
	if km, ok := val.Interface().(KeyMarshaler); ok ***REMOVED***
		if val.Kind() == reflect.Ptr && val.IsNil() ***REMOVED***
			return "", nil
		***REMOVED***
		buf, err := km.MarshalKey()
		if err == nil ***REMOVED***
			return buf, nil
		***REMOVED***
		return "", err
	***REMOVED***
	// keys implement encoding.TextMarshaler are marshaled.
	if km, ok := val.Interface().(encoding.TextMarshaler); ok ***REMOVED***
		if val.Kind() == reflect.Ptr && val.IsNil() ***REMOVED***
			return "", nil
		***REMOVED***

		buf, err := km.MarshalText()
		if err != nil ***REMOVED***
			return "", err
		***REMOVED***

		return string(buf), nil
	***REMOVED***

	switch val.Kind() ***REMOVED***
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return strconv.FormatInt(val.Int(), 10), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return strconv.FormatUint(val.Uint(), 10), nil
	***REMOVED***
	return "", fmt.Errorf("unsupported key type: %v", val.Type())
***REMOVED***

var keyUnmarshalerType = reflect.TypeOf((*KeyUnmarshaler)(nil)).Elem()
var textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()

func (mc *MapCodec) decodeKey(key string, keyType reflect.Type) (reflect.Value, error) ***REMOVED***
	keyVal := reflect.ValueOf(key)
	var err error
	switch ***REMOVED***
	// First, if EncodeKeysWithStringer is not enabled, try to decode withKeyUnmarshaler
	case !mc.EncodeKeysWithStringer && reflect.PtrTo(keyType).Implements(keyUnmarshalerType):
		keyVal = reflect.New(keyType)
		v := keyVal.Interface().(KeyUnmarshaler)
		err = v.UnmarshalKey(key)
		keyVal = keyVal.Elem()
	// Try to decode encoding.TextUnmarshalers.
	case reflect.PtrTo(keyType).Implements(textUnmarshalerType):
		keyVal = reflect.New(keyType)
		v := keyVal.Interface().(encoding.TextUnmarshaler)
		err = v.UnmarshalText([]byte(key))
		keyVal = keyVal.Elem()
	// Otherwise, go to type specific behavior
	default:
		switch keyType.Kind() ***REMOVED***
		case reflect.String:
			keyVal = reflect.ValueOf(key).Convert(keyType)
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			n, parseErr := strconv.ParseInt(key, 10, 64)
			if parseErr != nil || reflect.Zero(keyType).OverflowInt(n) ***REMOVED***
				err = fmt.Errorf("failed to unmarshal number key %v", key)
			***REMOVED***
			keyVal = reflect.ValueOf(n).Convert(keyType)
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			n, parseErr := strconv.ParseUint(key, 10, 64)
			if parseErr != nil || reflect.Zero(keyType).OverflowUint(n) ***REMOVED***
				err = fmt.Errorf("failed to unmarshal number key %v", key)
				break
			***REMOVED***
			keyVal = reflect.ValueOf(n).Convert(keyType)
		case reflect.Float32, reflect.Float64:
			if mc.EncodeKeysWithStringer ***REMOVED***
				parsed, err := strconv.ParseFloat(key, 64)
				if err != nil ***REMOVED***
					return keyVal, fmt.Errorf("Map key is defined to be a decimal type (%v) but got error %v", keyType.Kind(), err)
				***REMOVED***
				keyVal = reflect.ValueOf(parsed)
				break
			***REMOVED***
			fallthrough
		default:
			return keyVal, fmt.Errorf("unsupported key type: %v", keyType)
		***REMOVED***
	***REMOVED***
	return keyVal, err
***REMOVED***
