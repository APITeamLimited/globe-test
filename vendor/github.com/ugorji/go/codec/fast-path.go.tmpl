// +build !notfastpath

// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
// Use of this source code is governed by a MIT license found in the LICENSE file.

// Code generated from fast-path.go.tmpl - DO NOT EDIT.

package codec

// Fast path functions try to create a fast path encode or decode implementation
// for common maps and slices.
//
// We define the functions and register then in this single file
// so as not to pollute the encode.go and decode.go, and create a dependency in there.
// This file can be omitted without causing a build failure.
//
// The advantage of fast paths is:
//	  - Many calls bypass reflection altogether
// 
// Currently support
//	  - slice of all builtin types,
//	  - map of all builtin types to string or interface value
//	  - symmetrical maps of all builtin types (e.g. str-str, uint8-uint8)
// This should provide adequate "typical" implementations.
// 
// Note that fast track decode functions must handle values for which an address cannot be obtained.
// For example: 
//	 m2 := map[string]int***REMOVED******REMOVED***
//	 p2 := []interface***REMOVED******REMOVED******REMOVED***m2***REMOVED***
//	 // decoding into p2 will bomb if fast track functions do not treat like unaddressable.
// 

import (
	"reflect"
	"sort"
)

const fastpathEnabled = true

type fastpathT struct ***REMOVED******REMOVED***

var fastpathTV fastpathT

type fastpathE struct ***REMOVED***
	rtid uintptr
	rt reflect.Type 
	encfn func(*Encoder, *codecFnInfo, reflect.Value)
	decfn func(*Decoder, *codecFnInfo, reflect.Value)
***REMOVED***

type fastpathA [***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED***]fastpathE

func (x *fastpathA) index(rtid uintptr) int ***REMOVED***
	// use binary search to grab the index (adapted from sort/search.go)
	h, i, j := 0, 0, ***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED*** // len(x)
	for i < j ***REMOVED***
		h = i + (j-i)/2
		if x[h].rtid < rtid ***REMOVED***
			i = h + 1
		***REMOVED*** else ***REMOVED***
			j = h
		***REMOVED***
	***REMOVED***
	if i < ***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED*** && x[i].rtid == rtid ***REMOVED***
		return i
	***REMOVED***
	return -1
***REMOVED***

type fastpathAslice []fastpathE

func (x fastpathAslice) Len() int ***REMOVED*** return len(x) ***REMOVED***
func (x fastpathAslice) Less(i, j int) bool ***REMOVED*** return x[i].rtid < x[j].rtid ***REMOVED***
func (x fastpathAslice) Swap(i, j int) ***REMOVED*** x[i], x[j] = x[j], x[i] ***REMOVED***

var fastpathAV fastpathA

// due to possible initialization loop error, make fastpath in an init()
func init() ***REMOVED***
	i := 0
	fn := func(v interface***REMOVED******REMOVED***,
		fe func(*Encoder, *codecFnInfo, reflect.Value),
		fd func(*Decoder, *codecFnInfo, reflect.Value)) (f fastpathE) ***REMOVED***
		xrt := reflect.TypeOf(v)
		xptr := rt2id(xrt)
		fastpathAV[i] = fastpathE***REMOVED***xptr, xrt, fe, fd***REMOVED***
		i++
		return
	***REMOVED***
	***REMOVED******REMOVED***/* do not register []uint8 in fast-path */***REMOVED******REMOVED***
	***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED***if ne .Elem "uint8"***REMOVED******REMOVED***
	fn([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***(nil), (*Encoder).***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R, (*Decoder).***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R)***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	
	***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	fn(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***(nil), (*Encoder).***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R, (*Decoder).***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R)***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	
	sort.Sort(fastpathAslice(fastpathAV[:]))
***REMOVED***

// -- encode

// -- -- fast path type switch
func fastpathEncodeTypeSwitch(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***

***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED***if ne .Elem "uint8"***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, e)
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, e)***REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, e)
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, e)***REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

	default:
        _ = v // workaround https://github.com/golang/go/issues/12927 seen in go1.4
		return false
	***REMOVED***
	return true
***REMOVED***

***REMOVED******REMOVED***/*
**** removing this block, as they are never called directly ****



**** removing this block, as they are never called directly ****



func fastpathEncodeTypeSwitchSlice(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, e)
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, e)
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // workaround https://github.com/golang/go/issues/12927 seen in go1.4
		return false
	***REMOVED***
	return true
***REMOVED***

func fastpathEncodeTypeSwitchMap(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, e)
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, e)
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // workaround https://github.com/golang/go/issues/12927 seen in go1.4
		return false
	***REMOVED***
	return true
***REMOVED***



**** removing this block, as they are never called directly ****



**** removing this block, as they are never called directly ****
*/***REMOVED******REMOVED***

// -- -- fast path functions
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED*** 
func (e *Encoder) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R(f *codecFnInfo, rv reflect.Value) ***REMOVED***
	if f.ti.mbs ***REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "EncAsMap" false ***REMOVED******REMOVED***V(rv2i(rv).([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), e)
	***REMOVED*** else ***REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(rv2i(rv).([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), e)
	***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, e *Encoder) ***REMOVED***
	if v == nil ***REMOVED*** e.e.EncodeNil(); return ***REMOVED***
	ee, esep := e.e, e.hh.hasElemSeparators()
	ee.WriteArrayStart(len(v))
	if esep ***REMOVED***
		for _, v2 := range v ***REMOVED***
			ee.WriteArrayElem()
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		for _, v2 := range v ***REMOVED***
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED*** ***REMOVED******REMOVED***/*
	for _, v2 := range v ***REMOVED***
		if esep ***REMOVED*** ee.WriteArrayElem() ***REMOVED***
		***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
	***REMOVED*** */***REMOVED******REMOVED***
	ee.WriteArrayEnd()
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "EncAsMap" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, e *Encoder) ***REMOVED***
	ee, esep := e.e, e.hh.hasElemSeparators()
	if len(v)%2 == 1 ***REMOVED***
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	***REMOVED***
	ee.WriteMapStart(len(v) / 2)
	if esep ***REMOVED***
		for j, v2 := range v ***REMOVED***
			if j%2 == 0 ***REMOVED***
				ee.WriteMapElemKey()
			***REMOVED*** else ***REMOVED***
				ee.WriteMapElemValue()
			***REMOVED***
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		for _, v2 := range v ***REMOVED***
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED*** ***REMOVED******REMOVED***/*
	for j, v2 := range v ***REMOVED***
		if esep ***REMOVED***
			if j%2 == 0 ***REMOVED***
				ee.WriteMapElemKey()
			***REMOVED*** else ***REMOVED***
				ee.WriteMapElemValue()
			***REMOVED***
		***REMOVED***
		***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
	***REMOVED*** */***REMOVED******REMOVED***
	ee.WriteMapEnd()
***REMOVED***
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
func (e *Encoder) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R(f *codecFnInfo, rv reflect.Value) ***REMOVED***
	fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(rv2i(rv).(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), e)
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, e *Encoder) ***REMOVED***
	if v == nil ***REMOVED*** e.e.EncodeNil(); return ***REMOVED***
	ee, esep := e.e, e.hh.hasElemSeparators() 
	ee.WriteMapStart(len(v))
	if e.h.Canonical ***REMOVED***
		***REMOVED******REMOVED***if eq .MapKey "interface***REMOVED******REMOVED***"***REMOVED******REMOVED******REMOVED******REMOVED***/* out of band 
		*/***REMOVED******REMOVED***var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI ***REMOVED******REMOVED***/* put loop variables outside. seems currently needed for better perf */***REMOVED******REMOVED***
		for k2, _ := range v ***REMOVED***
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2 
			i++
		***REMOVED***
		sort.Sort(bytesISlice(v2))
		if esep ***REMOVED***
			for j := range v2 ***REMOVED***
				ee.WriteMapElemKey()
				e.asis(v2[j].v)
				ee.WriteMapElemValue()
				e.encode(v[v2[j].i])
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			for j := range v2 ***REMOVED***
				e.asis(v2[j].v)
				e.encode(v[v2[j].i])
			***REMOVED***
		***REMOVED*** ***REMOVED******REMOVED***/*
		for j := range v2 ***REMOVED***
			if esep ***REMOVED*** ee.WriteMapElemKey() ***REMOVED***
			e.asis(v2[j].v)
			if esep ***REMOVED*** ee.WriteMapElemValue() ***REMOVED***
			e.encode(v[v2[j].i])
		***REMOVED*** */***REMOVED******REMOVED*** ***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $x := sorttype .MapKey true***REMOVED******REMOVED***v2 := make([]***REMOVED******REMOVED*** $x ***REMOVED******REMOVED***, len(v))
		var i int 
		for k, _ := range v ***REMOVED***
			v2[i] = ***REMOVED******REMOVED*** $x ***REMOVED******REMOVED***(k)
			i++
		***REMOVED***
		sort.Sort(***REMOVED******REMOVED*** sorttype .MapKey false***REMOVED******REMOVED***(v2))
		if esep ***REMOVED***
			for _, k2 := range v2 ***REMOVED***
				ee.WriteMapElemKey()
				***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $y := printf "%s(k2)" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey $y ***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
				ee.WriteMapElemValue()
				***REMOVED******REMOVED*** $y := printf "v[%s(k2)]" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .Elem $y ***REMOVED******REMOVED***
			***REMOVED*** 
		***REMOVED*** else ***REMOVED***
			for _, k2 := range v2 ***REMOVED***
				***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $y := printf "%s(k2)" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey $y ***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
				***REMOVED******REMOVED*** $y := printf "v[%s(k2)]" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .Elem $y ***REMOVED******REMOVED***
			***REMOVED*** 
		***REMOVED*** ***REMOVED******REMOVED***/*
		for _, k2 := range v2 ***REMOVED***
			if esep ***REMOVED*** ee.WriteMapElemKey() ***REMOVED***
			***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $y := printf "%s(k2)" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey $y ***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
			if esep ***REMOVED*** ee.WriteMapElemValue() ***REMOVED***
			***REMOVED******REMOVED*** $y := printf "v[%s(k2)]" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .Elem $y ***REMOVED******REMOVED***
		***REMOVED*** */***REMOVED******REMOVED*** ***REMOVED******REMOVED***end***REMOVED******REMOVED***
	***REMOVED*** else ***REMOVED***
		if esep ***REMOVED***
			for k2, v2 := range v ***REMOVED***
				ee.WriteMapElemKey()
				***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey "k2"***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
				ee.WriteMapElemValue()
				***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			for k2, v2 := range v ***REMOVED***
				***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey "k2"***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
				***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
			***REMOVED***
		***REMOVED*** ***REMOVED******REMOVED***/*
		for k2, v2 := range v ***REMOVED***
			if esep ***REMOVED*** ee.WriteMapElemKey() ***REMOVED***
			***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***ee.EncodeString(cUTF8, k2)***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey "k2"***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
			if esep ***REMOVED*** ee.WriteMapElemValue() ***REMOVED***
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED*** */***REMOVED******REMOVED***
	***REMOVED***
	ee.WriteMapEnd()
***REMOVED***
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

// -- decode

// -- -- fast path type switch
func fastpathDecodeTypeSwitch(iv interface***REMOVED******REMOVED***, d *Decoder) bool ***REMOVED***
     var changed bool
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED***if ne .Elem "uint8"***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
        var v2 []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***
		v2, changed = fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, false, d)
        if changed && len(v) > 0 && len(v2) > 0 && !(len(v2) == len(v) && &v2[0] == &v[0]) ***REMOVED***
			copy(v, v2)
		***REMOVED***
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
        var v2 []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***
		v2, changed = fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*v, true, d)
        if changed ***REMOVED***
			*v = v2 
		***REMOVED******REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED***/*
// maps only change if nil, and in that case, there's no point copying
*/***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, false, d)
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
         var v2 map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***
		v2, changed = fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*v, true, d)
        if changed ***REMOVED***
			*v = v2 
		***REMOVED******REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // workaround https://github.com/golang/go/issues/12927 seen in go1.4
		return false
	***REMOVED***
	return true
***REMOVED***

func fastpathDecodeSetZeroTypeSwitch(iv interface***REMOVED******REMOVED***) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***: 
		*v = nil ***REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***: 
		*v = nil ***REMOVED******REMOVED***/*
*/***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // workaround https://github.com/golang/go/issues/12927 seen in go1.4
		return false
	***REMOVED***
	return true
***REMOVED***

// -- -- fast path functions
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
***REMOVED******REMOVED***/*
Slices can change if they 
- did not come from an array
- are addressable (from a ptr)
- are settable (e.g. contained in an interface***REMOVED******REMOVED***)
*/***REMOVED******REMOVED***
func (d *Decoder) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R(f *codecFnInfo, rv reflect.Value) ***REMOVED***
	if array := f.seq == seqTypeArray; !array && rv.Kind() == reflect.Ptr ***REMOVED***
		vp := rv2i(rv).(*[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		v, changed := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, !array, d)
        if changed ***REMOVED*** *vp = v ***REMOVED***
	***REMOVED*** else ***REMOVED***
		v := rv2i(rv).([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
        v2, changed := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, !array, d)
        if changed && len(v) > 0 && len(v2) > 0 && !(len(v2) == len(v) && &v2[0] == &v[0]) ***REMOVED***
           copy(v, v2)
        ***REMOVED***
	***REMOVED***
***REMOVED***
func (f fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***X(vp *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, d *Decoder) ***REMOVED***
	v, changed := f.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, true, d)
    if changed ***REMOVED*** *vp = v ***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, canChange bool, d *Decoder) (_ []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, changed bool) ***REMOVED***
	dd := d.d***REMOVED******REMOVED***/*
	    // if dd.isContainerType(valueTypeNil) ***REMOVED*** dd.TryDecodeAsNil()
    */***REMOVED******REMOVED***
	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 ***REMOVED***
		if canChange ***REMOVED***
			if v == nil ***REMOVED*** v = []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** ***REMOVED*** else if len(v) != 0 ***REMOVED*** v = v[:0] ***REMOVED***
			changed = true
		***REMOVED***
		slh.End()
		return v, changed
	***REMOVED***
	hasLen := containerLenS > 0
	var xlen int 
	if hasLen && canChange ***REMOVED***
		if containerLenS > cap(v) ***REMOVED***
			xlen = decInferLen(containerLenS, d.h.MaxInitLen, ***REMOVED******REMOVED*** .Size ***REMOVED******REMOVED***)
			if xlen <= cap(v) ***REMOVED***
				v = v[:xlen]
			***REMOVED*** else ***REMOVED***
				v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
			***REMOVED***
			changed = true 
		***REMOVED*** else if containerLenS != len(v) ***REMOVED***
			v = v[:containerLenS]
			changed = true
		***REMOVED***
	***REMOVED***
	j := 0
	for ; (hasLen && j < containerLenS) || !(hasLen || dd.CheckBreak()); j++ ***REMOVED***
		if j == 0 && len(v) == 0 && canChange ***REMOVED***
			if hasLen ***REMOVED***
				xlen = decInferLen(containerLenS, d.h.MaxInitLen, ***REMOVED******REMOVED*** .Size ***REMOVED******REMOVED***)
			***REMOVED*** else ***REMOVED***
				xlen = 8
			***REMOVED***
			v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
			changed = true 
		***REMOVED***
		// if indefinite, etc, then expand the slice if necessary
		var decodeIntoBlank bool
		if j >= len(v) ***REMOVED***
			if canChange ***REMOVED***
				v = append(v, ***REMOVED******REMOVED*** zerocmd .Elem ***REMOVED******REMOVED***)
				changed = true
			***REMOVED*** else ***REMOVED***
				d.arrayCannotExpand(len(v), j+1)
				decodeIntoBlank = true
			***REMOVED***
		***REMOVED*** 
		slh.ElemContainerState(j)
		if decodeIntoBlank ***REMOVED***
			d.swallow()
		***REMOVED*** else if dd.TryDecodeAsNil() ***REMOVED***
			v[j] = ***REMOVED******REMOVED*** zerocmd .Elem ***REMOVED******REMOVED***
		***REMOVED*** else ***REMOVED***
			***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***d.decode(&v[j])***REMOVED******REMOVED*** else ***REMOVED******REMOVED***v[j] = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED***
	if canChange ***REMOVED***
		if j < len(v) ***REMOVED***
			v = v[:j]
			changed = true
		***REMOVED*** else if j == 0 && v == nil ***REMOVED***
			v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, 0)
			changed = true
		***REMOVED***
	***REMOVED***
	slh.End()
	return v, changed 
***REMOVED***
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
***REMOVED******REMOVED***/*
Maps can change if they are
- addressable (from a ptr)
- settable (e.g. contained in an interface***REMOVED******REMOVED***)
*/***REMOVED******REMOVED***
func (d *Decoder) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R(f *codecFnInfo, rv reflect.Value) ***REMOVED***
	if rv.Kind() == reflect.Ptr ***REMOVED***
		vp := rv2i(rv).(*map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		v, changed := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, true, d);
		if changed ***REMOVED*** *vp = v ***REMOVED***
	***REMOVED*** else ***REMOVED***
	    fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(rv2i(rv).(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), false, d)
    ***REMOVED***
***REMOVED***
func (f fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***X(vp *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, d *Decoder) ***REMOVED***
	v, changed := f.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, true, d)
	if changed ***REMOVED*** *vp = v ***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, canChange bool, 
	d *Decoder) (_ map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, changed bool) ***REMOVED***
	dd, esep := d.d, d.hh.hasElemSeparators()***REMOVED******REMOVED***/*
	    // if dd.isContainerType(valueTypeNil) ***REMOVED***dd.TryDecodeAsNil()
    */***REMOVED******REMOVED***
	containerLen := dd.ReadMapStart()
	if canChange && v == nil ***REMOVED***
		xlen := decInferLen(containerLen, d.h.MaxInitLen, ***REMOVED******REMOVED*** .Size ***REMOVED******REMOVED***)
		v = make(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
		changed = true
	***REMOVED***
	if containerLen == 0 ***REMOVED***
		dd.ReadMapEnd()
		return v, changed
	***REMOVED***
	***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***mapGet := v != nil && !d.h.MapValueReset && !d.h.InterfaceReset
    ***REMOVED******REMOVED***end***REMOVED******REMOVED***var mk ***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***
	var mv ***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***
	hasLen := containerLen > 0
	for j := 0; (hasLen && j < containerLen) || !(hasLen || dd.CheckBreak()); j++ ***REMOVED***
		if esep ***REMOVED*** dd.ReadMapElemKey() ***REMOVED***
		***REMOVED******REMOVED*** if eq .MapKey "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***mk = nil 
		d.decode(&mk)
		if bv, bok := mk.([]byte); bok ***REMOVED***
			mk = d.string(bv) ***REMOVED******REMOVED***/* // maps cannot have []byte as key. switch to string. */***REMOVED******REMOVED***
		***REMOVED******REMOVED******REMOVED*** else ***REMOVED******REMOVED***mk = ***REMOVED******REMOVED*** decmd .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
		if esep ***REMOVED*** dd.ReadMapElemValue() ***REMOVED***
		if dd.TryDecodeAsNil() ***REMOVED***
			if v == nil ***REMOVED******REMOVED*** else if d.h.DeleteOnNilMapValue ***REMOVED*** delete(v, mk) ***REMOVED*** else ***REMOVED*** v[mk] = ***REMOVED******REMOVED*** zerocmd .Elem ***REMOVED******REMOVED*** ***REMOVED***
			continue 
		***REMOVED***
		***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***if mapGet ***REMOVED*** mv = v[mk] ***REMOVED*** else ***REMOVED*** mv = nil ***REMOVED***
		d.decode(&mv)***REMOVED******REMOVED*** else ***REMOVED******REMOVED***mv = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
		if v != nil ***REMOVED*** v[mk] = mv ***REMOVED***
	***REMOVED***
	dd.ReadMapEnd()
	return v, changed
***REMOVED***
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
