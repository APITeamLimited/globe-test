// +build !notfastpath

// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
// Use of this source code is governed by a MIT license found in the LICENSE file.

// ************************************************************
// DO NOT EDIT. 
// THIS FILE IS AUTO-GENERATED from fast-path.go.tmpl
// ************************************************************

package codec

// Fast path functions try to create a fast path encode or decode implementation
// for common maps and slices.
//
// We define the functions and register then in this single file
// so as not to pollute the encode.go and decode.go, and create a dependency in there.
// This file can be omitted without causing a build failure.
//
// The advantage of fast paths is:
//    - Many calls bypass reflection altogether
// 
// Currently support
//    - slice of all builtin types,
//    - map of all builtin types to string or interface value
//    - symmetrical maps of all builtin types (e.g. str-str, uint8-uint8)
// This should provide adequate "typical" implementations.
// 
// Note that fast track decode functions must handle values for which an address cannot be obtained.
// For example: 
//   m2 := map[string]int***REMOVED******REMOVED***
//   p2 := []interface***REMOVED******REMOVED******REMOVED***m2***REMOVED***
//   // decoding into p2 will bomb if fast track functions do not treat like unaddressable.
// 

import (
	"reflect"
	"sort"
)

const fastpathEnabled = true

const fastpathCheckNilFalse = false // for reflect
const fastpathCheckNilTrue = true // for type switch

type fastpathT struct ***REMOVED******REMOVED***

var fastpathTV fastpathT

type fastpathE struct ***REMOVED***
	rtid uintptr
	rt reflect.Type 
	encfn func(*encFnInfo, reflect.Value)
	decfn func(*decFnInfo, reflect.Value)
***REMOVED***

type fastpathA [***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED***]fastpathE

func (x *fastpathA) index(rtid uintptr) int ***REMOVED***
	// use binary search to grab the index (adapted from sort/search.go)
	h, i, j := 0, 0, ***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED*** // len(x)
	for i < j ***REMOVED***
		h = i + (j-i)/2
		if x[h].rtid < rtid ***REMOVED***
			i = h + 1
		***REMOVED*** else ***REMOVED***
			j = h
		***REMOVED***
	***REMOVED***
	if i < ***REMOVED******REMOVED*** .FastpathLen ***REMOVED******REMOVED*** && x[i].rtid == rtid ***REMOVED***
		return i
	***REMOVED***
	return -1
***REMOVED***

type fastpathAslice []fastpathE

func (x fastpathAslice) Len() int ***REMOVED*** return len(x) ***REMOVED***
func (x fastpathAslice) Less(i, j int) bool ***REMOVED*** return x[i].rtid < x[j].rtid ***REMOVED***
func (x fastpathAslice) Swap(i, j int) ***REMOVED*** x[i], x[j] = x[j], x[i] ***REMOVED***

var fastpathAV fastpathA

// due to possible initialization loop error, make fastpath in an init()
func init() ***REMOVED***
	i := 0
	fn := func(v interface***REMOVED******REMOVED***, fe func(*encFnInfo, reflect.Value), fd func(*decFnInfo, reflect.Value)) (f fastpathE) ***REMOVED***
		xrt := reflect.TypeOf(v)
		xptr := reflect.ValueOf(xrt).Pointer()
		fastpathAV[i] = fastpathE***REMOVED***xptr, xrt, fe, fd***REMOVED***
		i++
		return
	***REMOVED***
	
	***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	fn([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***(nil), (*encFnInfo).***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R, (*decFnInfo).***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R)***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	
	***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	fn(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***(nil), (*encFnInfo).***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R, (*decFnInfo).***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R)***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	
	sort.Sort(fastpathAslice(fastpathAV[:]))
***REMOVED***

// -- encode

// -- -- fast path type switch
func fastpathEncodeTypeSwitch(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***else***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***end***REMOVED******REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, fastpathCheckNilTrue, e)***REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***else***REMOVED******REMOVED***
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***end***REMOVED******REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, fastpathCheckNilTrue, e)
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	***REMOVED***
	return true
***REMOVED***

func fastpathEncodeTypeSwitchSlice(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, fastpathCheckNilTrue, e)
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, fastpathCheckNilTrue, e)
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	***REMOVED***
	return true
***REMOVED***

func fastpathEncodeTypeSwitchMap(iv interface***REMOVED******REMOVED***, e *Encoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v, fastpathCheckNilTrue, e)
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(*v, fastpathCheckNilTrue, e)
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	***REMOVED***
	return true
***REMOVED***

// -- -- fast path functions
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED*** 

func (f *encFnInfo) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R(rv reflect.Value) ***REMOVED***
	if f.ti.mbs ***REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "EncAsMap" false ***REMOVED******REMOVED***V(rv.Interface().([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), fastpathCheckNilFalse, f.e)
	***REMOVED*** else ***REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(rv.Interface().([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), fastpathCheckNilFalse, f.e)
	***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, e *Encoder) ***REMOVED***
	ee := e.e
	cr := e.cr
	if checkNil && v == nil ***REMOVED***
		ee.EncodeNil()
		return
	***REMOVED***
	ee.EncodeArrayStart(len(v))
	for _, v2 := range v ***REMOVED***
		if cr != nil ***REMOVED*** cr.sendContainerState(containerArrayElem) ***REMOVED***
		***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
	***REMOVED***
	if cr != nil ***REMOVED*** cr.sendContainerState(containerArrayEnd) ***REMOVED******REMOVED******REMOVED***/* ee.EncodeEnd() */***REMOVED******REMOVED***
***REMOVED***

func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "EncAsMap" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, e *Encoder) ***REMOVED***
	ee := e.e
	cr := e.cr
	if checkNil && v == nil ***REMOVED***
		ee.EncodeNil()
		return
	***REMOVED***
	if len(v)%2 == 1 ***REMOVED***
		e.errorf("mapBySlice requires even slice length, but got %v", len(v))
		return
	***REMOVED***
	ee.EncodeMapStart(len(v) / 2)
	for j, v2 := range v ***REMOVED***
		if cr != nil ***REMOVED***
			if j%2 == 0 ***REMOVED***
				cr.sendContainerState(containerMapKey)
			***REMOVED*** else ***REMOVED***
				cr.sendContainerState(containerMapValue)
			***REMOVED***
		***REMOVED***
		***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
	***REMOVED***
	if cr != nil ***REMOVED*** cr.sendContainerState(containerMapEnd) ***REMOVED***
***REMOVED***

***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***

func (f *encFnInfo) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathEnc" false ***REMOVED******REMOVED***R(rv reflect.Value) ***REMOVED***
	fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(rv.Interface().(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***), fastpathCheckNilFalse, f.e)
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Enc" false ***REMOVED******REMOVED***V(v map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, e *Encoder) ***REMOVED***
	ee := e.e
	cr := e.cr
	if checkNil && v == nil ***REMOVED***
		ee.EncodeNil()
		return
	***REMOVED***
	ee.EncodeMapStart(len(v))
	***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***asSymbols := e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	***REMOVED******REMOVED***end***REMOVED******REMOVED***if e.h.Canonical ***REMOVED***
		***REMOVED******REMOVED***if eq .MapKey "interface***REMOVED******REMOVED***"***REMOVED******REMOVED******REMOVED******REMOVED***/* out of band 
		*/***REMOVED******REMOVED***var mksv []byte = make([]byte, 0, len(v)*16) // temporary byte slice for the encoding
		e2 := NewEncoderBytes(&mksv, e.hh)
		v2 := make([]bytesI, len(v))
		var i, l int
		var vp *bytesI ***REMOVED******REMOVED***/* put loop variables outside. seems currently needed for better perf */***REMOVED******REMOVED***
		for k2, _ := range v ***REMOVED***
			l = len(mksv)
			e2.MustEncode(k2)
			vp = &v2[i]
			vp.v = mksv[l:]
			vp.i = k2 
			i++
		***REMOVED***
		sort.Sort(bytesISlice(v2))
		for j := range v2 ***REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapKey) ***REMOVED***
			e.asis(v2[j].v)
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapValue) ***REMOVED***
			e.encode(v[v2[j].i])
		***REMOVED*** ***REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $x := sorttype .MapKey true***REMOVED******REMOVED***v2 := make([]***REMOVED******REMOVED*** $x ***REMOVED******REMOVED***, len(v))
		var i int 
		for k, _ := range v ***REMOVED***
			v2[i] = ***REMOVED******REMOVED*** $x ***REMOVED******REMOVED***(k)
			i++
		***REMOVED***
		sort.Sort(***REMOVED******REMOVED*** sorttype .MapKey false***REMOVED******REMOVED***(v2))
		for _, k2 := range v2 ***REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapKey) ***REMOVED***
			***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***if asSymbols ***REMOVED***
				ee.EncodeSymbol(k2)
			***REMOVED*** else ***REMOVED***
				ee.EncodeString(c_UTF8, k2)
			***REMOVED******REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** $y := printf "%s(k2)" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey $y ***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapValue) ***REMOVED***
			***REMOVED******REMOVED*** $y := printf "v[%s(k2)]" .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .Elem $y ***REMOVED******REMOVED***
		***REMOVED*** ***REMOVED******REMOVED***end***REMOVED******REMOVED***
	***REMOVED*** else ***REMOVED***
		for k2, v2 := range v ***REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapKey) ***REMOVED***
			***REMOVED******REMOVED***if eq .MapKey "string"***REMOVED******REMOVED***if asSymbols ***REMOVED***
				ee.EncodeSymbol(k2)
			***REMOVED*** else ***REMOVED***
				ee.EncodeString(c_UTF8, k2)
			***REMOVED******REMOVED******REMOVED***else***REMOVED******REMOVED******REMOVED******REMOVED*** encmd .MapKey "k2"***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapValue) ***REMOVED***
			***REMOVED******REMOVED*** encmd .Elem "v2"***REMOVED******REMOVED***
		***REMOVED***
	***REMOVED***
	if cr != nil ***REMOVED*** cr.sendContainerState(containerMapEnd) ***REMOVED******REMOVED******REMOVED***/* ee.EncodeEnd() */***REMOVED******REMOVED***
***REMOVED***

***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***

// -- decode

// -- -- fast path type switch
func fastpathDecodeTypeSwitch(iv interface***REMOVED******REMOVED***, d *Decoder) bool ***REMOVED***
	switch v := iv.(type) ***REMOVED***
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***else***REMOVED******REMOVED***
	case map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***end***REMOVED******REMOVED***
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, fastpathCheckNilFalse, false, d)***REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
	case *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***else***REMOVED******REMOVED***
	case *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***:***REMOVED******REMOVED***end***REMOVED******REMOVED***
		v2, changed2 := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*v, fastpathCheckNilFalse, true, d)
		if changed2 ***REMOVED***
			*v = v2 
		***REMOVED***
***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
	default:
        _ = v // TODO: workaround https://github.com/golang/go/issues/12927 (remove after go 1.6 release)
		return false
	***REMOVED***
	return true
***REMOVED***

// -- -- fast path functions
***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if not .MapKey ***REMOVED******REMOVED***
***REMOVED******REMOVED***/*
Slices can change if they 
- did not come from an array
- are addressable (from a ptr)
- are settable (e.g. contained in an interface***REMOVED******REMOVED***)
*/***REMOVED******REMOVED***
func (f *decFnInfo) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R(rv reflect.Value) ***REMOVED*** 
	array := f.seq == seqTypeArray
	if !array && rv.CanAddr() ***REMOVED*** ***REMOVED******REMOVED***/* // CanSet => CanAddr + Exported */***REMOVED******REMOVED***
		vp := rv.Addr().Interface().(*[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		v, changed := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, fastpathCheckNilFalse, !array, f.d)
		if changed ***REMOVED***
			*vp = v
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		v := rv.Interface().([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, fastpathCheckNilFalse, false, f.d)
	***REMOVED***
***REMOVED***

func (f fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***X(vp *[]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, d *Decoder) ***REMOVED***
	v, changed := f.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, checkNil, true, d)
	if changed ***REMOVED***
		*vp = v 
	***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, canChange bool, d *Decoder) (_ []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, changed bool) ***REMOVED***
	dd := d.d
	***REMOVED******REMOVED***/* // if dd.isContainerType(valueTypeNil) ***REMOVED*** dd.TryDecodeAsNil() */***REMOVED******REMOVED***
	if checkNil && dd.TryDecodeAsNil() ***REMOVED***
		if v != nil ***REMOVED***
			changed = true 
		***REMOVED***
		return nil, changed 
	***REMOVED***

	slh, containerLenS := d.decSliceHelperStart()
	if containerLenS == 0 ***REMOVED***
		if canChange ***REMOVED***
			if v == nil ***REMOVED***
				v = []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED******REMOVED******REMOVED***
			***REMOVED*** else if len(v) != 0 ***REMOVED***
				v = v[:0]
			***REMOVED***
			changed = true
		***REMOVED***
		slh.End()
		return v, changed
	***REMOVED***
	
	if containerLenS > 0 ***REMOVED***
		x2read := containerLenS
		var xtrunc bool 
		if containerLenS > cap(v) ***REMOVED***
			if canChange ***REMOVED*** ***REMOVED******REMOVED***/*
				// fast-path is for "basic" immutable types, so no need to copy them over
				// s := make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, decInferLen(containerLenS, d.h.MaxInitLen))
				// copy(s, v[:cap(v)])
				// v = s */***REMOVED******REMOVED***
				var xlen int 
                xlen, xtrunc = decInferLen(containerLenS, d.h.MaxInitLen, ***REMOVED******REMOVED*** .Size ***REMOVED******REMOVED***)
				if xtrunc ***REMOVED***
					if xlen <= cap(v) ***REMOVED***
						v = v[:xlen]
					***REMOVED*** else ***REMOVED***
						v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
					***REMOVED***
				***REMOVED*** else ***REMOVED***
					v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
				***REMOVED***
				changed = true
			***REMOVED*** else ***REMOVED***
				d.arrayCannotExpand(len(v), containerLenS)
			***REMOVED***
			x2read = len(v)
		***REMOVED*** else if containerLenS != len(v) ***REMOVED***
			if canChange ***REMOVED***
				v = v[:containerLenS]
				changed = true
			***REMOVED***
		***REMOVED*** ***REMOVED******REMOVED***/* // all checks done. cannot go past len. */***REMOVED******REMOVED***
		j := 0
		for ; j < x2read; j++ ***REMOVED***
			slh.ElemContainerState(j)
			***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***d.decode(&v[j])***REMOVED******REMOVED*** else ***REMOVED******REMOVED***v[j] = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
		***REMOVED***
		if xtrunc ***REMOVED*** ***REMOVED******REMOVED***/* // means canChange=true, changed=true already. */***REMOVED******REMOVED***
			for ; j < containerLenS; j++ ***REMOVED***
				v = append(v, ***REMOVED******REMOVED*** zerocmd .Elem ***REMOVED******REMOVED***)
				slh.ElemContainerState(j)
				***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***d.decode(&v[j])***REMOVED******REMOVED*** else ***REMOVED******REMOVED***v[j] = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			***REMOVED***
		***REMOVED*** else if !canChange ***REMOVED***
			for ; j < containerLenS; j++ ***REMOVED***
				slh.ElemContainerState(j)
				d.swallow()
			***REMOVED***
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		breakFound := dd.CheckBreak() ***REMOVED******REMOVED***/* check break first, so we can initialize v with a capacity of 4 if necessary */***REMOVED******REMOVED***
		if breakFound ***REMOVED***
			if canChange ***REMOVED***
				if v == nil ***REMOVED***
					v = []***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED******REMOVED******REMOVED***
				***REMOVED*** else if len(v) != 0 ***REMOVED***
					v = v[:0]
				***REMOVED***
				changed = true
			***REMOVED***
			slh.End()
			return v, changed
		***REMOVED***
		if cap(v) == 0 ***REMOVED***
			v = make([]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, 1, 4)
			changed = true
		***REMOVED***
		j := 0	
		for ; !breakFound; j++ ***REMOVED***
			if j >= len(v) ***REMOVED*** 
				if canChange ***REMOVED***
					v = append(v, ***REMOVED******REMOVED*** zerocmd .Elem ***REMOVED******REMOVED***)
					changed = true
				***REMOVED*** else ***REMOVED***
					d.arrayCannotExpand(len(v), j+1)
				***REMOVED***
			***REMOVED***
			slh.ElemContainerState(j)
			if j < len(v) ***REMOVED*** ***REMOVED******REMOVED***/* // all checks done. cannot go past len. */***REMOVED******REMOVED***
				***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***d.decode(&v[j])
				***REMOVED******REMOVED*** else ***REMOVED******REMOVED***v[j] = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			***REMOVED*** else ***REMOVED***
				d.swallow()
			***REMOVED***
			breakFound = dd.CheckBreak()
		***REMOVED***
		if canChange && j < len(v) ***REMOVED***
			v = v[:j]
			changed = true
		***REMOVED***
	***REMOVED***
	slh.End() 
	return v, changed 
***REMOVED***

***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***


***REMOVED******REMOVED***range .Values***REMOVED******REMOVED******REMOVED******REMOVED***if not .Primitive***REMOVED******REMOVED******REMOVED******REMOVED***if .MapKey ***REMOVED******REMOVED***
***REMOVED******REMOVED***/*
Maps can change if they are
- addressable (from a ptr)
- settable (e.g. contained in an interface***REMOVED******REMOVED***)
*/***REMOVED******REMOVED***
func (f *decFnInfo) ***REMOVED******REMOVED*** .MethodNamePfx "fastpathDec" false ***REMOVED******REMOVED***R(rv reflect.Value) ***REMOVED*** 
	if rv.CanAddr() ***REMOVED***
		vp := rv.Addr().Interface().(*map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		v, changed := fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, fastpathCheckNilFalse, true, f.d)
		if changed ***REMOVED***
			*vp = v
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		v := rv.Interface().(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***)
		fastpathTV.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v, fastpathCheckNilFalse, false, f.d)
	***REMOVED***
***REMOVED***
func (f fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***X(vp *map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, d *Decoder) ***REMOVED***
	v, changed := f.***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(*vp, checkNil, true, d)
	if changed ***REMOVED***
		*vp = v 
	***REMOVED***
***REMOVED***
func (_ fastpathT) ***REMOVED******REMOVED*** .MethodNamePfx "Dec" false ***REMOVED******REMOVED***V(v map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, checkNil bool, canChange bool, 
	d *Decoder) (_ map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, changed bool) ***REMOVED***
	dd := d.d
	cr := d.cr
	***REMOVED******REMOVED***/* // if dd.isContainerType(valueTypeNil) ***REMOVED***dd.TryDecodeAsNil() */***REMOVED******REMOVED***
	if checkNil && dd.TryDecodeAsNil() ***REMOVED***
		if v != nil ***REMOVED***
			changed = true
		***REMOVED*** 
		return nil, changed
	***REMOVED***

	containerLen := dd.ReadMapStart()
	if canChange && v == nil ***REMOVED***
		xlen, _ := decInferLen(containerLen, d.h.MaxInitLen, ***REMOVED******REMOVED*** .Size ***REMOVED******REMOVED***)
		v = make(map[***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***]***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***, xlen)
		changed = true
	***REMOVED***
	***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***mapGet := !d.h.MapValueReset && !d.h.InterfaceReset***REMOVED******REMOVED***end***REMOVED******REMOVED***
	var mk ***REMOVED******REMOVED*** .MapKey ***REMOVED******REMOVED***
	var mv ***REMOVED******REMOVED*** .Elem ***REMOVED******REMOVED***
	if containerLen > 0 ***REMOVED***
		for j := 0; j < containerLen; j++ ***REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapKey) ***REMOVED***
			***REMOVED******REMOVED*** if eq .MapKey "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***mk = nil 
			d.decode(&mk)
			if bv, bok := mk.([]byte); bok ***REMOVED***
				mk = d.string(bv) ***REMOVED******REMOVED***/* // maps cannot have []byte as key. switch to string. */***REMOVED******REMOVED***
			***REMOVED******REMOVED******REMOVED*** else ***REMOVED******REMOVED***mk = ***REMOVED******REMOVED*** decmd .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapValue) ***REMOVED***
			***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***if mapGet ***REMOVED*** mv = v[mk] ***REMOVED*** else ***REMOVED*** mv = nil ***REMOVED***
			d.decode(&mv)***REMOVED******REMOVED*** else ***REMOVED******REMOVED***mv = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			if v != nil ***REMOVED***
				v[mk] = mv
			***REMOVED***
		***REMOVED***
	***REMOVED*** else if containerLen < 0 ***REMOVED***
		for j := 0; !dd.CheckBreak(); j++ ***REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapKey) ***REMOVED***
			***REMOVED******REMOVED*** if eq .MapKey "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***mk = nil 
			d.decode(&mk)
			if bv, bok := mk.([]byte); bok ***REMOVED***
				mk = d.string(bv) ***REMOVED******REMOVED***/* // maps cannot have []byte as key. switch to string. */***REMOVED******REMOVED***
			***REMOVED******REMOVED******REMOVED*** else ***REMOVED******REMOVED***mk = ***REMOVED******REMOVED*** decmd .MapKey ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			if cr != nil ***REMOVED*** cr.sendContainerState(containerMapValue) ***REMOVED***
			***REMOVED******REMOVED*** if eq .Elem "interface***REMOVED******REMOVED***" ***REMOVED******REMOVED***if mapGet ***REMOVED*** mv = v[mk] ***REMOVED*** else ***REMOVED*** mv = nil ***REMOVED***
			d.decode(&mv)***REMOVED******REMOVED*** else ***REMOVED******REMOVED***mv = ***REMOVED******REMOVED*** decmd .Elem ***REMOVED******REMOVED******REMOVED******REMOVED*** end ***REMOVED******REMOVED***
			if v != nil ***REMOVED***
				v[mk] = mv
			***REMOVED***
		***REMOVED***
	***REMOVED***
	if cr != nil ***REMOVED*** cr.sendContainerState(containerMapEnd) ***REMOVED***
	return v, changed
***REMOVED***

***REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED******REMOVED******REMOVED***end***REMOVED******REMOVED***
