// Go support for Protocol Buffers - Google's data interchange format
//
// Copyright 2010 The Go Authors.  All rights reserved.
// https://github.com/golang/protobuf
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package proto

/*
 * Types and routines for supporting protocol buffer extensions.
 */

import (
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"sync"
)

// ErrMissingExtension is the error returned by GetExtension if the named extension is not in the message.
var ErrMissingExtension = errors.New("proto: missing extension")

// ExtensionRange represents a range of message extensions for a protocol buffer.
// Used in code generated by the protocol compiler.
type ExtensionRange struct ***REMOVED***
	Start, End int32 // both inclusive
***REMOVED***

// extendableProto is an interface implemented by any protocol buffer generated by the current
// proto compiler that may be extended.
type extendableProto interface ***REMOVED***
	Message
	ExtensionRangeArray() []ExtensionRange
	extensionsWrite() map[int32]Extension
	extensionsRead() (map[int32]Extension, sync.Locker)
***REMOVED***

// extendableProtoV1 is an interface implemented by a protocol buffer generated by the previous
// version of the proto compiler that may be extended.
type extendableProtoV1 interface ***REMOVED***
	Message
	ExtensionRangeArray() []ExtensionRange
	ExtensionMap() map[int32]Extension
***REMOVED***

// extensionAdapter is a wrapper around extendableProtoV1 that implements extendableProto.
type extensionAdapter struct ***REMOVED***
	extendableProtoV1
***REMOVED***

func (e extensionAdapter) extensionsWrite() map[int32]Extension ***REMOVED***
	return e.ExtensionMap()
***REMOVED***

func (e extensionAdapter) extensionsRead() (map[int32]Extension, sync.Locker) ***REMOVED***
	return e.ExtensionMap(), notLocker***REMOVED******REMOVED***
***REMOVED***

// notLocker is a sync.Locker whose Lock and Unlock methods are nops.
type notLocker struct***REMOVED******REMOVED***

func (n notLocker) Lock()   ***REMOVED******REMOVED***
func (n notLocker) Unlock() ***REMOVED******REMOVED***

// extendable returns the extendableProto interface for the given generated proto message.
// If the proto message has the old extension format, it returns a wrapper that implements
// the extendableProto interface.
func extendable(p interface***REMOVED******REMOVED***) (extendableProto, bool) ***REMOVED***
	if ep, ok := p.(extendableProto); ok ***REMOVED***
		return ep, ok
	***REMOVED***
	if ep, ok := p.(extendableProtoV1); ok ***REMOVED***
		return extensionAdapter***REMOVED***ep***REMOVED***, ok
	***REMOVED***
	return nil, false
***REMOVED***

// XXX_InternalExtensions is an internal representation of proto extensions.
//
// Each generated message struct type embeds an anonymous XXX_InternalExtensions field,
// thus gaining the unexported 'extensions' method, which can be called only from the proto package.
//
// The methods of XXX_InternalExtensions are not concurrency safe in general,
// but calls to logically read-only methods such as has and get may be executed concurrently.
type XXX_InternalExtensions struct ***REMOVED***
	// The struct must be indirect so that if a user inadvertently copies a
	// generated message and its embedded XXX_InternalExtensions, they
	// avoid the mayhem of a copied mutex.
	//
	// The mutex serializes all logically read-only operations to p.extensionMap.
	// It is up to the client to ensure that write operations to p.extensionMap are
	// mutually exclusive with other accesses.
	p *struct ***REMOVED***
		mu           sync.Mutex
		extensionMap map[int32]Extension
	***REMOVED***
***REMOVED***

// extensionsWrite returns the extension map, creating it on first use.
func (e *XXX_InternalExtensions) extensionsWrite() map[int32]Extension ***REMOVED***
	if e.p == nil ***REMOVED***
		e.p = new(struct ***REMOVED***
			mu           sync.Mutex
			extensionMap map[int32]Extension
		***REMOVED***)
		e.p.extensionMap = make(map[int32]Extension)
	***REMOVED***
	return e.p.extensionMap
***REMOVED***

// extensionsRead returns the extensions map for read-only use.  It may be nil.
// The caller must hold the returned mutex's lock when accessing Elements within the map.
func (e *XXX_InternalExtensions) extensionsRead() (map[int32]Extension, sync.Locker) ***REMOVED***
	if e.p == nil ***REMOVED***
		return nil, nil
	***REMOVED***
	return e.p.extensionMap, &e.p.mu
***REMOVED***

var extendableProtoType = reflect.TypeOf((*extendableProto)(nil)).Elem()
var extendableProtoV1Type = reflect.TypeOf((*extendableProtoV1)(nil)).Elem()

// ExtensionDesc represents an extension specification.
// Used in generated code from the protocol compiler.
type ExtensionDesc struct ***REMOVED***
	ExtendedType  Message     // nil pointer to the type that is being extended
	ExtensionType interface***REMOVED******REMOVED*** // nil pointer to the extension type
	Field         int32       // field number
	Name          string      // fully-qualified name of extension, for text formatting
	Tag           string      // protobuf tag style
	Filename      string      // name of the file in which the extension is defined
***REMOVED***

func (ed *ExtensionDesc) repeated() bool ***REMOVED***
	t := reflect.TypeOf(ed.ExtensionType)
	return t.Kind() == reflect.Slice && t.Elem().Kind() != reflect.Uint8
***REMOVED***

// Extension represents an extension in a message.
type Extension struct ***REMOVED***
	// When an extension is stored in a message using SetExtension
	// only desc and value are set. When the message is marshaled
	// enc will be set to the encoded form of the message.
	//
	// When a message is unmarshaled and contains extensions, each
	// extension will have only enc set. When such an extension is
	// accessed using GetExtension (or GetExtensions) desc and value
	// will be set.
	desc  *ExtensionDesc
	value interface***REMOVED******REMOVED***
	enc   []byte
***REMOVED***

// SetRawExtension is for testing only.
func SetRawExtension(base Message, id int32, b []byte) ***REMOVED***
	epb, ok := extendable(base)
	if !ok ***REMOVED***
		return
	***REMOVED***
	extmap := epb.extensionsWrite()
	extmap[id] = Extension***REMOVED***enc: b***REMOVED***
***REMOVED***

// isExtensionField returns true iff the given field number is in an extension range.
func isExtensionField(pb extendableProto, field int32) bool ***REMOVED***
	for _, er := range pb.ExtensionRangeArray() ***REMOVED***
		if er.Start <= field && field <= er.End ***REMOVED***
			return true
		***REMOVED***
	***REMOVED***
	return false
***REMOVED***

// checkExtensionTypes checks that the given extension is valid for pb.
func checkExtensionTypes(pb extendableProto, extension *ExtensionDesc) error ***REMOVED***
	var pbi interface***REMOVED******REMOVED*** = pb
	// Check the extended type.
	if ea, ok := pbi.(extensionAdapter); ok ***REMOVED***
		pbi = ea.extendableProtoV1
	***REMOVED***
	if a, b := reflect.TypeOf(pbi), reflect.TypeOf(extension.ExtendedType); a != b ***REMOVED***
		return errors.New("proto: bad extended type; " + b.String() + " does not extend " + a.String())
	***REMOVED***
	// Check the range.
	if !isExtensionField(pb, extension.Field) ***REMOVED***
		return errors.New("proto: bad extension number; not in declared ranges")
	***REMOVED***
	return nil
***REMOVED***

// extPropKey is sufficient to uniquely identify an extension.
type extPropKey struct ***REMOVED***
	base  reflect.Type
	field int32
***REMOVED***

var extProp = struct ***REMOVED***
	sync.RWMutex
	m map[extPropKey]*Properties
***REMOVED******REMOVED***
	m: make(map[extPropKey]*Properties),
***REMOVED***

func extensionProperties(ed *ExtensionDesc) *Properties ***REMOVED***
	key := extPropKey***REMOVED***base: reflect.TypeOf(ed.ExtendedType), field: ed.Field***REMOVED***

	extProp.RLock()
	if prop, ok := extProp.m[key]; ok ***REMOVED***
		extProp.RUnlock()
		return prop
	***REMOVED***
	extProp.RUnlock()

	extProp.Lock()
	defer extProp.Unlock()
	// Check again.
	if prop, ok := extProp.m[key]; ok ***REMOVED***
		return prop
	***REMOVED***

	prop := new(Properties)
	prop.Init(reflect.TypeOf(ed.ExtensionType), "unknown_name", ed.Tag, nil)
	extProp.m[key] = prop
	return prop
***REMOVED***

// encode encodes any unmarshaled (unencoded) extensions in e.
func encodeExtensions(e *XXX_InternalExtensions) error ***REMOVED***
	m, mu := e.extensionsRead()
	if m == nil ***REMOVED***
		return nil // fast path
	***REMOVED***
	mu.Lock()
	defer mu.Unlock()
	return encodeExtensionsMap(m)
***REMOVED***

// encode encodes any unmarshaled (unencoded) extensions in e.
func encodeExtensionsMap(m map[int32]Extension) error ***REMOVED***
	for k, e := range m ***REMOVED***
		if e.value == nil || e.desc == nil ***REMOVED***
			// Extension is only in its encoded form.
			continue
		***REMOVED***

		// We don't skip extensions that have an encoded form set,
		// because the extension value may have been mutated after
		// the last time this function was called.

		et := reflect.TypeOf(e.desc.ExtensionType)
		props := extensionProperties(e.desc)

		p := NewBuffer(nil)
		// If e.value has type T, the encoder expects a *struct***REMOVED*** X T ***REMOVED***.
		// Pass a *T with a zero field and hope it all works out.
		x := reflect.New(et)
		x.Elem().Set(reflect.ValueOf(e.value))
		if err := props.enc(p, props, toStructPointer(x)); err != nil ***REMOVED***
			return err
		***REMOVED***
		e.enc = p.buf
		m[k] = e
	***REMOVED***
	return nil
***REMOVED***

func extensionsSize(e *XXX_InternalExtensions) (n int) ***REMOVED***
	m, mu := e.extensionsRead()
	if m == nil ***REMOVED***
		return 0
	***REMOVED***
	mu.Lock()
	defer mu.Unlock()
	return extensionsMapSize(m)
***REMOVED***

func extensionsMapSize(m map[int32]Extension) (n int) ***REMOVED***
	for _, e := range m ***REMOVED***
		if e.value == nil || e.desc == nil ***REMOVED***
			// Extension is only in its encoded form.
			n += len(e.enc)
			continue
		***REMOVED***

		// We don't skip extensions that have an encoded form set,
		// because the extension value may have been mutated after
		// the last time this function was called.

		et := reflect.TypeOf(e.desc.ExtensionType)
		props := extensionProperties(e.desc)

		// If e.value has type T, the encoder expects a *struct***REMOVED*** X T ***REMOVED***.
		// Pass a *T with a zero field and hope it all works out.
		x := reflect.New(et)
		x.Elem().Set(reflect.ValueOf(e.value))
		n += props.size(props, toStructPointer(x))
	***REMOVED***
	return
***REMOVED***

// HasExtension returns whether the given extension is present in pb.
func HasExtension(pb Message, extension *ExtensionDesc) bool ***REMOVED***
	// TODO: Check types, field numbers, etc.?
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return false
	***REMOVED***
	extmap, mu := epb.extensionsRead()
	if extmap == nil ***REMOVED***
		return false
	***REMOVED***
	mu.Lock()
	_, ok = extmap[extension.Field]
	mu.Unlock()
	return ok
***REMOVED***

// ClearExtension removes the given extension from pb.
func ClearExtension(pb Message, extension *ExtensionDesc) ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return
	***REMOVED***
	// TODO: Check types, field numbers, etc.?
	extmap := epb.extensionsWrite()
	delete(extmap, extension.Field)
***REMOVED***

// GetExtension parses and returns the given extension of pb.
// If the extension is not present and has no default value it returns ErrMissingExtension.
func GetExtension(pb Message, extension *ExtensionDesc) (interface***REMOVED******REMOVED***, error) ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return nil, errors.New("proto: not an extendable proto")
	***REMOVED***

	if err := checkExtensionTypes(epb, extension); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	emap, mu := epb.extensionsRead()
	if emap == nil ***REMOVED***
		return defaultExtensionValue(extension)
	***REMOVED***
	mu.Lock()
	defer mu.Unlock()
	e, ok := emap[extension.Field]
	if !ok ***REMOVED***
		// defaultExtensionValue returns the default value or
		// ErrMissingExtension if there is no default.
		return defaultExtensionValue(extension)
	***REMOVED***

	if e.value != nil ***REMOVED***
		// Already decoded. Check the descriptor, though.
		if e.desc != extension ***REMOVED***
			// This shouldn't happen. If it does, it means that
			// GetExtension was called twice with two different
			// descriptors with the same field number.
			return nil, errors.New("proto: descriptor conflict")
		***REMOVED***
		return e.value, nil
	***REMOVED***

	v, err := decodeExtension(e.enc, extension)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	// Remember the decoded version and drop the encoded version.
	// That way it is safe to mutate what we return.
	e.value = v
	e.desc = extension
	e.enc = nil
	emap[extension.Field] = e
	return e.value, nil
***REMOVED***

// defaultExtensionValue returns the default value for extension.
// If no default for an extension is defined ErrMissingExtension is returned.
func defaultExtensionValue(extension *ExtensionDesc) (interface***REMOVED******REMOVED***, error) ***REMOVED***
	t := reflect.TypeOf(extension.ExtensionType)
	props := extensionProperties(extension)

	sf, _, err := fieldDefault(t, props)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	if sf == nil || sf.value == nil ***REMOVED***
		// There is no default value.
		return nil, ErrMissingExtension
	***REMOVED***

	if t.Kind() != reflect.Ptr ***REMOVED***
		// We do not need to return a Ptr, we can directly return sf.value.
		return sf.value, nil
	***REMOVED***

	// We need to return an interface***REMOVED******REMOVED*** that is a pointer to sf.value.
	value := reflect.New(t).Elem()
	value.Set(reflect.New(value.Type().Elem()))
	if sf.kind == reflect.Int32 ***REMOVED***
		// We may have an int32 or an enum, but the underlying data is int32.
		// Since we can't set an int32 into a non int32 reflect.value directly
		// set it as a int32.
		value.Elem().SetInt(int64(sf.value.(int32)))
	***REMOVED*** else ***REMOVED***
		value.Elem().Set(reflect.ValueOf(sf.value))
	***REMOVED***
	return value.Interface(), nil
***REMOVED***

// decodeExtension decodes an extension encoded in b.
func decodeExtension(b []byte, extension *ExtensionDesc) (interface***REMOVED******REMOVED***, error) ***REMOVED***
	o := NewBuffer(b)

	t := reflect.TypeOf(extension.ExtensionType)

	props := extensionProperties(extension)

	// t is a pointer to a struct, pointer to basic type or a slice.
	// Allocate a "field" to store the pointer/slice itself; the
	// pointer/slice will be stored here. We pass
	// the address of this field to props.dec.
	// This passes a zero field and a *t and lets props.dec
	// interpret it as a *struct***REMOVED*** x t ***REMOVED***.
	value := reflect.New(t).Elem()

	for ***REMOVED***
		// Discard wire type and field number varint. It isn't needed.
		if _, err := o.DecodeVarint(); err != nil ***REMOVED***
			return nil, err
		***REMOVED***

		if err := props.dec(o, props, toStructPointer(value.Addr())); err != nil ***REMOVED***
			return nil, err
		***REMOVED***

		if o.index >= len(o.buf) ***REMOVED***
			break
		***REMOVED***
	***REMOVED***
	return value.Interface(), nil
***REMOVED***

// GetExtensions returns a slice of the extensions present in pb that are also listed in es.
// The returned slice has the same length as es; missing extensions will appear as nil elements.
func GetExtensions(pb Message, es []*ExtensionDesc) (extensions []interface***REMOVED******REMOVED***, err error) ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return nil, errors.New("proto: not an extendable proto")
	***REMOVED***
	extensions = make([]interface***REMOVED******REMOVED***, len(es))
	for i, e := range es ***REMOVED***
		extensions[i], err = GetExtension(epb, e)
		if err == ErrMissingExtension ***REMOVED***
			err = nil
		***REMOVED***
		if err != nil ***REMOVED***
			return
		***REMOVED***
	***REMOVED***
	return
***REMOVED***

// ExtensionDescs returns a new slice containing pb's extension descriptors, in undefined order.
// For non-registered extensions, ExtensionDescs returns an incomplete descriptor containing
// just the Field field, which defines the extension's field number.
func ExtensionDescs(pb Message) ([]*ExtensionDesc, error) ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return nil, fmt.Errorf("proto: %T is not an extendable proto.Message", pb)
	***REMOVED***
	registeredExtensions := RegisteredExtensions(pb)

	emap, mu := epb.extensionsRead()
	if emap == nil ***REMOVED***
		return nil, nil
	***REMOVED***
	mu.Lock()
	defer mu.Unlock()
	extensions := make([]*ExtensionDesc, 0, len(emap))
	for extid, e := range emap ***REMOVED***
		desc := e.desc
		if desc == nil ***REMOVED***
			desc = registeredExtensions[extid]
			if desc == nil ***REMOVED***
				desc = &ExtensionDesc***REMOVED***Field: extid***REMOVED***
			***REMOVED***
		***REMOVED***

		extensions = append(extensions, desc)
	***REMOVED***
	return extensions, nil
***REMOVED***

// SetExtension sets the specified extension of pb to the specified value.
func SetExtension(pb Message, extension *ExtensionDesc, value interface***REMOVED******REMOVED***) error ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return errors.New("proto: not an extendable proto")
	***REMOVED***
	if err := checkExtensionTypes(epb, extension); err != nil ***REMOVED***
		return err
	***REMOVED***
	typ := reflect.TypeOf(extension.ExtensionType)
	if typ != reflect.TypeOf(value) ***REMOVED***
		return errors.New("proto: bad extension value type")
	***REMOVED***
	// nil extension values need to be caught early, because the
	// encoder can't distinguish an ErrNil due to a nil extension
	// from an ErrNil due to a missing field. Extensions are
	// always optional, so the encoder would just swallow the error
	// and drop all the extensions from the encoded message.
	if reflect.ValueOf(value).IsNil() ***REMOVED***
		return fmt.Errorf("proto: SetExtension called with nil value of type %T", value)
	***REMOVED***

	extmap := epb.extensionsWrite()
	extmap[extension.Field] = Extension***REMOVED***desc: extension, value: value***REMOVED***
	return nil
***REMOVED***

// ClearAllExtensions clears all extensions from pb.
func ClearAllExtensions(pb Message) ***REMOVED***
	epb, ok := extendable(pb)
	if !ok ***REMOVED***
		return
	***REMOVED***
	m := epb.extensionsWrite()
	for k := range m ***REMOVED***
		delete(m, k)
	***REMOVED***
***REMOVED***

// A global registry of extensions.
// The generated code will register the generated descriptors by calling RegisterExtension.

var extensionMaps = make(map[reflect.Type]map[int32]*ExtensionDesc)

// RegisterExtension is called from the generated code.
func RegisterExtension(desc *ExtensionDesc) ***REMOVED***
	st := reflect.TypeOf(desc.ExtendedType).Elem()
	m := extensionMaps[st]
	if m == nil ***REMOVED***
		m = make(map[int32]*ExtensionDesc)
		extensionMaps[st] = m
	***REMOVED***
	if _, ok := m[desc.Field]; ok ***REMOVED***
		panic("proto: duplicate extension registered: " + st.String() + " " + strconv.Itoa(int(desc.Field)))
	***REMOVED***
	m[desc.Field] = desc
***REMOVED***

// RegisteredExtensions returns a map of the registered extensions of a
// protocol buffer struct, indexed by the extension number.
// The argument pb should be a nil pointer to the struct type.
func RegisteredExtensions(pb Message) map[int32]*ExtensionDesc ***REMOVED***
	return extensionMaps[reflect.TypeOf(pb).Elem()]
***REMOVED***
