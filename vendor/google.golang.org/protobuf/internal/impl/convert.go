// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package impl

import (
	"fmt"
	"reflect"

	"google.golang.org/protobuf/reflect/protoreflect"
)

// unwrapper unwraps the value to the underlying value.
// This is implemented by List and Map.
type unwrapper interface ***REMOVED***
	protoUnwrap() interface***REMOVED******REMOVED***
***REMOVED***

// A Converter coverts to/from Go reflect.Value types and protobuf protoreflect.Value types.
type Converter interface ***REMOVED***
	// PBValueOf converts a reflect.Value to a protoreflect.Value.
	PBValueOf(reflect.Value) protoreflect.Value

	// GoValueOf converts a protoreflect.Value to a reflect.Value.
	GoValueOf(protoreflect.Value) reflect.Value

	// IsValidPB returns whether a protoreflect.Value is compatible with this type.
	IsValidPB(protoreflect.Value) bool

	// IsValidGo returns whether a reflect.Value is compatible with this type.
	IsValidGo(reflect.Value) bool

	// New returns a new field value.
	// For scalars, it returns the default value of the field.
	// For composite types, it returns a new mutable value.
	New() protoreflect.Value

	// Zero returns a new field value.
	// For scalars, it returns the default value of the field.
	// For composite types, it returns an immutable, empty value.
	Zero() protoreflect.Value
***REMOVED***

// NewConverter matches a Go type with a protobuf field and returns a Converter
// that converts between the two. Enums must be a named int32 kind that
// implements protoreflect.Enum, and messages must be pointer to a named
// struct type that implements protoreflect.ProtoMessage.
//
// This matcher deliberately supports a wider range of Go types than what
// protoc-gen-go historically generated to be able to automatically wrap some
// v1 messages generated by other forks of protoc-gen-go.
func NewConverter(t reflect.Type, fd protoreflect.FieldDescriptor) Converter ***REMOVED***
	switch ***REMOVED***
	case fd.IsList():
		return newListConverter(t, fd)
	case fd.IsMap():
		return newMapConverter(t, fd)
	default:
		return newSingularConverter(t, fd)
	***REMOVED***
	panic(fmt.Sprintf("invalid Go type %v for field %v", t, fd.FullName()))
***REMOVED***

var (
	boolType    = reflect.TypeOf(bool(false))
	int32Type   = reflect.TypeOf(int32(0))
	int64Type   = reflect.TypeOf(int64(0))
	uint32Type  = reflect.TypeOf(uint32(0))
	uint64Type  = reflect.TypeOf(uint64(0))
	float32Type = reflect.TypeOf(float32(0))
	float64Type = reflect.TypeOf(float64(0))
	stringType  = reflect.TypeOf(string(""))
	bytesType   = reflect.TypeOf([]byte(nil))
	byteType    = reflect.TypeOf(byte(0))
)

var (
	boolZero    = protoreflect.ValueOfBool(false)
	int32Zero   = protoreflect.ValueOfInt32(0)
	int64Zero   = protoreflect.ValueOfInt64(0)
	uint32Zero  = protoreflect.ValueOfUint32(0)
	uint64Zero  = protoreflect.ValueOfUint64(0)
	float32Zero = protoreflect.ValueOfFloat32(0)
	float64Zero = protoreflect.ValueOfFloat64(0)
	stringZero  = protoreflect.ValueOfString("")
	bytesZero   = protoreflect.ValueOfBytes(nil)
)

func newSingularConverter(t reflect.Type, fd protoreflect.FieldDescriptor) Converter ***REMOVED***
	defVal := func(fd protoreflect.FieldDescriptor, zero protoreflect.Value) protoreflect.Value ***REMOVED***
		if fd.Cardinality() == protoreflect.Repeated ***REMOVED***
			// Default isn't defined for repeated fields.
			return zero
		***REMOVED***
		return fd.Default()
	***REMOVED***
	switch fd.Kind() ***REMOVED***
	case protoreflect.BoolKind:
		if t.Kind() == reflect.Bool ***REMOVED***
			return &boolConverter***REMOVED***t, defVal(fd, boolZero)***REMOVED***
		***REMOVED***
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		if t.Kind() == reflect.Int32 ***REMOVED***
			return &int32Converter***REMOVED***t, defVal(fd, int32Zero)***REMOVED***
		***REMOVED***
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		if t.Kind() == reflect.Int64 ***REMOVED***
			return &int64Converter***REMOVED***t, defVal(fd, int64Zero)***REMOVED***
		***REMOVED***
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		if t.Kind() == reflect.Uint32 ***REMOVED***
			return &uint32Converter***REMOVED***t, defVal(fd, uint32Zero)***REMOVED***
		***REMOVED***
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		if t.Kind() == reflect.Uint64 ***REMOVED***
			return &uint64Converter***REMOVED***t, defVal(fd, uint64Zero)***REMOVED***
		***REMOVED***
	case protoreflect.FloatKind:
		if t.Kind() == reflect.Float32 ***REMOVED***
			return &float32Converter***REMOVED***t, defVal(fd, float32Zero)***REMOVED***
		***REMOVED***
	case protoreflect.DoubleKind:
		if t.Kind() == reflect.Float64 ***REMOVED***
			return &float64Converter***REMOVED***t, defVal(fd, float64Zero)***REMOVED***
		***REMOVED***
	case protoreflect.StringKind:
		if t.Kind() == reflect.String || (t.Kind() == reflect.Slice && t.Elem() == byteType) ***REMOVED***
			return &stringConverter***REMOVED***t, defVal(fd, stringZero)***REMOVED***
		***REMOVED***
	case protoreflect.BytesKind:
		if t.Kind() == reflect.String || (t.Kind() == reflect.Slice && t.Elem() == byteType) ***REMOVED***
			return &bytesConverter***REMOVED***t, defVal(fd, bytesZero)***REMOVED***
		***REMOVED***
	case protoreflect.EnumKind:
		// Handle enums, which must be a named int32 type.
		if t.Kind() == reflect.Int32 ***REMOVED***
			return newEnumConverter(t, fd)
		***REMOVED***
	case protoreflect.MessageKind, protoreflect.GroupKind:
		return newMessageConverter(t)
	***REMOVED***
	panic(fmt.Sprintf("invalid Go type %v for field %v", t, fd.FullName()))
***REMOVED***

type boolConverter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *boolConverter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfBool(v.Bool())
***REMOVED***
func (c *boolConverter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(v.Bool()).Convert(c.goType)
***REMOVED***
func (c *boolConverter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(bool)
	return ok
***REMOVED***
func (c *boolConverter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *boolConverter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *boolConverter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type int32Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *int32Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfInt32(int32(v.Int()))
***REMOVED***
func (c *int32Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(int32(v.Int())).Convert(c.goType)
***REMOVED***
func (c *int32Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(int32)
	return ok
***REMOVED***
func (c *int32Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *int32Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *int32Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type int64Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *int64Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfInt64(int64(v.Int()))
***REMOVED***
func (c *int64Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(int64(v.Int())).Convert(c.goType)
***REMOVED***
func (c *int64Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(int64)
	return ok
***REMOVED***
func (c *int64Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *int64Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *int64Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type uint32Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *uint32Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfUint32(uint32(v.Uint()))
***REMOVED***
func (c *uint32Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(uint32(v.Uint())).Convert(c.goType)
***REMOVED***
func (c *uint32Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(uint32)
	return ok
***REMOVED***
func (c *uint32Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *uint32Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *uint32Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type uint64Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *uint64Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfUint64(uint64(v.Uint()))
***REMOVED***
func (c *uint64Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(uint64(v.Uint())).Convert(c.goType)
***REMOVED***
func (c *uint64Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(uint64)
	return ok
***REMOVED***
func (c *uint64Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *uint64Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *uint64Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type float32Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *float32Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfFloat32(float32(v.Float()))
***REMOVED***
func (c *float32Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(float32(v.Float())).Convert(c.goType)
***REMOVED***
func (c *float32Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(float32)
	return ok
***REMOVED***
func (c *float32Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *float32Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *float32Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type float64Converter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *float64Converter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfFloat64(float64(v.Float()))
***REMOVED***
func (c *float64Converter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(float64(v.Float())).Convert(c.goType)
***REMOVED***
func (c *float64Converter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(float64)
	return ok
***REMOVED***
func (c *float64Converter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *float64Converter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *float64Converter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type stringConverter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *stringConverter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfString(v.Convert(stringType).String())
***REMOVED***
func (c *stringConverter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	// pref.Value.String never panics, so we go through an interface
	// conversion here to check the type.
	s := v.Interface().(string)
	if c.goType.Kind() == reflect.Slice && s == "" ***REMOVED***
		return reflect.Zero(c.goType) // ensure empty string is []byte(nil)
	***REMOVED***
	return reflect.ValueOf(s).Convert(c.goType)
***REMOVED***
func (c *stringConverter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(string)
	return ok
***REMOVED***
func (c *stringConverter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *stringConverter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *stringConverter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type bytesConverter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func (c *bytesConverter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	if c.goType.Kind() == reflect.String && v.Len() == 0 ***REMOVED***
		return protoreflect.ValueOfBytes(nil) // ensure empty string is []byte(nil)
	***REMOVED***
	return protoreflect.ValueOfBytes(v.Convert(bytesType).Bytes())
***REMOVED***
func (c *bytesConverter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(v.Bytes()).Convert(c.goType)
***REMOVED***
func (c *bytesConverter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().([]byte)
	return ok
***REMOVED***
func (c *bytesConverter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***
func (c *bytesConverter) New() protoreflect.Value  ***REMOVED*** return c.def ***REMOVED***
func (c *bytesConverter) Zero() protoreflect.Value ***REMOVED*** return c.def ***REMOVED***

type enumConverter struct ***REMOVED***
	goType reflect.Type
	def    protoreflect.Value
***REMOVED***

func newEnumConverter(goType reflect.Type, fd protoreflect.FieldDescriptor) Converter ***REMOVED***
	var def protoreflect.Value
	if fd.Cardinality() == protoreflect.Repeated ***REMOVED***
		def = protoreflect.ValueOfEnum(fd.Enum().Values().Get(0).Number())
	***REMOVED*** else ***REMOVED***
		def = fd.Default()
	***REMOVED***
	return &enumConverter***REMOVED***goType, def***REMOVED***
***REMOVED***

func (c *enumConverter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	return protoreflect.ValueOfEnum(protoreflect.EnumNumber(v.Int()))
***REMOVED***

func (c *enumConverter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	return reflect.ValueOf(v.Enum()).Convert(c.goType)
***REMOVED***

func (c *enumConverter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	_, ok := v.Interface().(protoreflect.EnumNumber)
	return ok
***REMOVED***

func (c *enumConverter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***

func (c *enumConverter) New() protoreflect.Value ***REMOVED***
	return c.def
***REMOVED***

func (c *enumConverter) Zero() protoreflect.Value ***REMOVED***
	return c.def
***REMOVED***

type messageConverter struct ***REMOVED***
	goType reflect.Type
***REMOVED***

func newMessageConverter(goType reflect.Type) Converter ***REMOVED***
	return &messageConverter***REMOVED***goType***REMOVED***
***REMOVED***

func (c *messageConverter) PBValueOf(v reflect.Value) protoreflect.Value ***REMOVED***
	if v.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", v.Type(), c.goType))
	***REMOVED***
	if c.isNonPointer() ***REMOVED***
		if v.CanAddr() ***REMOVED***
			v = v.Addr() // T => *T
		***REMOVED*** else ***REMOVED***
			v = reflect.Zero(reflect.PtrTo(v.Type()))
		***REMOVED***
	***REMOVED***
	if m, ok := v.Interface().(protoreflect.ProtoMessage); ok ***REMOVED***
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	***REMOVED***
	return protoreflect.ValueOfMessage(legacyWrapMessage(v))
***REMOVED***

func (c *messageConverter) GoValueOf(v protoreflect.Value) reflect.Value ***REMOVED***
	m := v.Message()
	var rv reflect.Value
	if u, ok := m.(unwrapper); ok ***REMOVED***
		rv = reflect.ValueOf(u.protoUnwrap())
	***REMOVED*** else ***REMOVED***
		rv = reflect.ValueOf(m.Interface())
	***REMOVED***
	if c.isNonPointer() ***REMOVED***
		if rv.Type() != reflect.PtrTo(c.goType) ***REMOVED***
			panic(fmt.Sprintf("invalid type: got %v, want %v", rv.Type(), reflect.PtrTo(c.goType)))
		***REMOVED***
		if !rv.IsNil() ***REMOVED***
			rv = rv.Elem() // *T => T
		***REMOVED*** else ***REMOVED***
			rv = reflect.Zero(rv.Type().Elem())
		***REMOVED***
	***REMOVED***
	if rv.Type() != c.goType ***REMOVED***
		panic(fmt.Sprintf("invalid type: got %v, want %v", rv.Type(), c.goType))
	***REMOVED***
	return rv
***REMOVED***

func (c *messageConverter) IsValidPB(v protoreflect.Value) bool ***REMOVED***
	m := v.Message()
	var rv reflect.Value
	if u, ok := m.(unwrapper); ok ***REMOVED***
		rv = reflect.ValueOf(u.protoUnwrap())
	***REMOVED*** else ***REMOVED***
		rv = reflect.ValueOf(m.Interface())
	***REMOVED***
	if c.isNonPointer() ***REMOVED***
		return rv.Type() == reflect.PtrTo(c.goType)
	***REMOVED***
	return rv.Type() == c.goType
***REMOVED***

func (c *messageConverter) IsValidGo(v reflect.Value) bool ***REMOVED***
	return v.IsValid() && v.Type() == c.goType
***REMOVED***

func (c *messageConverter) New() protoreflect.Value ***REMOVED***
	if c.isNonPointer() ***REMOVED***
		return c.PBValueOf(reflect.New(c.goType).Elem())
	***REMOVED***
	return c.PBValueOf(reflect.New(c.goType.Elem()))
***REMOVED***

func (c *messageConverter) Zero() protoreflect.Value ***REMOVED***
	return c.PBValueOf(reflect.Zero(c.goType))
***REMOVED***

// isNonPointer reports whether the type is a non-pointer type.
// This never occurs for generated message types.
func (c *messageConverter) isNonPointer() bool ***REMOVED***
	return c.goType.Kind() != reflect.Ptr
***REMOVED***
