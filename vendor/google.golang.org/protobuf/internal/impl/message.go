// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package impl

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"

	"google.golang.org/protobuf/internal/genid"
	"google.golang.org/protobuf/reflect/protoreflect"
	pref "google.golang.org/protobuf/reflect/protoreflect"
)

// MessageInfo provides protobuf related functionality for a given Go type
// that represents a message. A given instance of MessageInfo is tied to
// exactly one Go type, which must be a pointer to a struct type.
//
// The exported fields must be populated before any methods are called
// and cannot be mutated after set.
type MessageInfo struct ***REMOVED***
	// GoReflectType is the underlying message Go type and must be populated.
	GoReflectType reflect.Type // pointer to struct

	// Desc is the underlying message descriptor type and must be populated.
	Desc pref.MessageDescriptor

	// Exporter must be provided in a purego environment in order to provide
	// access to unexported fields.
	Exporter exporter

	// OneofWrappers is list of pointers to oneof wrapper struct types.
	OneofWrappers []interface***REMOVED******REMOVED***

	initMu   sync.Mutex // protects all unexported fields
	initDone uint32

	reflectMessageInfo // for reflection implementation
	coderMessageInfo   // for fast-path method implementations
***REMOVED***

// exporter is a function that returns a reference to the ith field of v,
// where v is a pointer to a struct. It returns nil if it does not support
// exporting the requested field (e.g., already exported).
type exporter func(v interface***REMOVED******REMOVED***, i int) interface***REMOVED******REMOVED***

// getMessageInfo returns the MessageInfo for any message type that
// is generated by our implementation of protoc-gen-go (for v2 and on).
// If it is unable to obtain a MessageInfo, it returns nil.
func getMessageInfo(mt reflect.Type) *MessageInfo ***REMOVED***
	m, ok := reflect.Zero(mt).Interface().(pref.ProtoMessage)
	if !ok ***REMOVED***
		return nil
	***REMOVED***
	mr, ok := m.ProtoReflect().(interface***REMOVED*** ProtoMessageInfo() *MessageInfo ***REMOVED***)
	if !ok ***REMOVED***
		return nil
	***REMOVED***
	return mr.ProtoMessageInfo()
***REMOVED***

func (mi *MessageInfo) init() ***REMOVED***
	// This function is called in the hot path. Inline the sync.Once logic,
	// since allocating a closure for Once.Do is expensive.
	// Keep init small to ensure that it can be inlined.
	if atomic.LoadUint32(&mi.initDone) == 0 ***REMOVED***
		mi.initOnce()
	***REMOVED***
***REMOVED***

func (mi *MessageInfo) initOnce() ***REMOVED***
	mi.initMu.Lock()
	defer mi.initMu.Unlock()
	if mi.initDone == 1 ***REMOVED***
		return
	***REMOVED***

	t := mi.GoReflectType
	if t.Kind() != reflect.Ptr && t.Elem().Kind() != reflect.Struct ***REMOVED***
		panic(fmt.Sprintf("got %v, want *struct kind", t))
	***REMOVED***
	t = t.Elem()

	si := mi.makeStructInfo(t)
	mi.makeReflectFuncs(t, si)
	mi.makeCoderMethods(t, si)

	atomic.StoreUint32(&mi.initDone, 1)
***REMOVED***

// getPointer returns the pointer for a message, which should be of
// the type of the MessageInfo. If the message is of a different type,
// it returns ok==false.
func (mi *MessageInfo) getPointer(m pref.Message) (p pointer, ok bool) ***REMOVED***
	switch m := m.(type) ***REMOVED***
	case *messageState:
		return m.pointer(), m.messageInfo() == mi
	case *messageReflectWrapper:
		return m.pointer(), m.messageInfo() == mi
	***REMOVED***
	return pointer***REMOVED******REMOVED***, false
***REMOVED***

type (
	SizeCache       = int32
	WeakFields      = map[int32]protoreflect.ProtoMessage
	UnknownFields   = []byte
	ExtensionFields = map[int32]ExtensionField
)

var (
	sizecacheType       = reflect.TypeOf(SizeCache(0))
	weakFieldsType      = reflect.TypeOf(WeakFields(nil))
	unknownFieldsType   = reflect.TypeOf(UnknownFields(nil))
	extensionFieldsType = reflect.TypeOf(ExtensionFields(nil))
)

type structInfo struct ***REMOVED***
	sizecacheOffset offset
	weakOffset      offset
	unknownOffset   offset
	extensionOffset offset

	fieldsByNumber        map[pref.FieldNumber]reflect.StructField
	oneofsByName          map[pref.Name]reflect.StructField
	oneofWrappersByType   map[reflect.Type]pref.FieldNumber
	oneofWrappersByNumber map[pref.FieldNumber]reflect.Type
***REMOVED***

func (mi *MessageInfo) makeStructInfo(t reflect.Type) structInfo ***REMOVED***
	si := structInfo***REMOVED***
		sizecacheOffset: invalidOffset,
		weakOffset:      invalidOffset,
		unknownOffset:   invalidOffset,
		extensionOffset: invalidOffset,

		fieldsByNumber:        map[pref.FieldNumber]reflect.StructField***REMOVED******REMOVED***,
		oneofsByName:          map[pref.Name]reflect.StructField***REMOVED******REMOVED***,
		oneofWrappersByType:   map[reflect.Type]pref.FieldNumber***REMOVED******REMOVED***,
		oneofWrappersByNumber: map[pref.FieldNumber]reflect.Type***REMOVED******REMOVED***,
	***REMOVED***

fieldLoop:
	for i := 0; i < t.NumField(); i++ ***REMOVED***
		switch f := t.Field(i); f.Name ***REMOVED***
		case genid.SizeCache_goname, genid.SizeCacheA_goname:
			if f.Type == sizecacheType ***REMOVED***
				si.sizecacheOffset = offsetOf(f, mi.Exporter)
			***REMOVED***
		case genid.WeakFields_goname, genid.WeakFieldsA_goname:
			if f.Type == weakFieldsType ***REMOVED***
				si.weakOffset = offsetOf(f, mi.Exporter)
			***REMOVED***
		case genid.UnknownFields_goname, genid.UnknownFieldsA_goname:
			if f.Type == unknownFieldsType ***REMOVED***
				si.unknownOffset = offsetOf(f, mi.Exporter)
			***REMOVED***
		case genid.ExtensionFields_goname, genid.ExtensionFieldsA_goname, genid.ExtensionFieldsB_goname:
			if f.Type == extensionFieldsType ***REMOVED***
				si.extensionOffset = offsetOf(f, mi.Exporter)
			***REMOVED***
		default:
			for _, s := range strings.Split(f.Tag.Get("protobuf"), ",") ***REMOVED***
				if len(s) > 0 && strings.Trim(s, "0123456789") == "" ***REMOVED***
					n, _ := strconv.ParseUint(s, 10, 64)
					si.fieldsByNumber[pref.FieldNumber(n)] = f
					continue fieldLoop
				***REMOVED***
			***REMOVED***
			if s := f.Tag.Get("protobuf_oneof"); len(s) > 0 ***REMOVED***
				si.oneofsByName[pref.Name(s)] = f
				continue fieldLoop
			***REMOVED***
		***REMOVED***
	***REMOVED***

	// Derive a mapping of oneof wrappers to fields.
	oneofWrappers := mi.OneofWrappers
	for _, method := range []string***REMOVED***"XXX_OneofFuncs", "XXX_OneofWrappers"***REMOVED*** ***REMOVED***
		if fn, ok := reflect.PtrTo(t).MethodByName(method); ok ***REMOVED***
			for _, v := range fn.Func.Call([]reflect.Value***REMOVED***reflect.Zero(fn.Type.In(0))***REMOVED***) ***REMOVED***
				if vs, ok := v.Interface().([]interface***REMOVED******REMOVED***); ok ***REMOVED***
					oneofWrappers = vs
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
	for _, v := range oneofWrappers ***REMOVED***
		tf := reflect.TypeOf(v).Elem()
		f := tf.Field(0)
		for _, s := range strings.Split(f.Tag.Get("protobuf"), ",") ***REMOVED***
			if len(s) > 0 && strings.Trim(s, "0123456789") == "" ***REMOVED***
				n, _ := strconv.ParseUint(s, 10, 64)
				si.oneofWrappersByType[tf] = pref.FieldNumber(n)
				si.oneofWrappersByNumber[pref.FieldNumber(n)] = tf
				break
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return si
***REMOVED***

func (mi *MessageInfo) New() protoreflect.Message ***REMOVED***
	return mi.MessageOf(reflect.New(mi.GoReflectType.Elem()).Interface())
***REMOVED***
func (mi *MessageInfo) Zero() protoreflect.Message ***REMOVED***
	return mi.MessageOf(reflect.Zero(mi.GoReflectType).Interface())
***REMOVED***
func (mi *MessageInfo) Descriptor() protoreflect.MessageDescriptor ***REMOVED*** return mi.Desc ***REMOVED***
