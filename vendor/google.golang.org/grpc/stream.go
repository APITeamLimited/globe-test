/*
 *
 * Copyright 2014 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package grpc

import (
	"context"
	"errors"
	"io"
	"math"
	"strconv"
	"sync"
	"time"

	"golang.org/x/net/trace"
	"google.golang.org/grpc/balancer"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/encoding"
	"google.golang.org/grpc/internal/balancerload"
	"google.golang.org/grpc/internal/binarylog"
	"google.golang.org/grpc/internal/channelz"
	"google.golang.org/grpc/internal/grpcrand"
	"google.golang.org/grpc/internal/grpcutil"
	iresolver "google.golang.org/grpc/internal/resolver"
	"google.golang.org/grpc/internal/serviceconfig"
	"google.golang.org/grpc/internal/transport"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/peer"
	"google.golang.org/grpc/stats"
	"google.golang.org/grpc/status"
)

// StreamHandler defines the handler called by gRPC server to complete the
// execution of a streaming RPC. If a StreamHandler returns an error, it
// should be produced by the status package, or else gRPC will use
// codes.Unknown as the status code and err.Error() as the status message
// of the RPC.
type StreamHandler func(srv interface***REMOVED******REMOVED***, stream ServerStream) error

// StreamDesc represents a streaming RPC service's method specification.
type StreamDesc struct ***REMOVED***
	StreamName string
	Handler    StreamHandler

	// At least one of these is true.
	ServerStreams bool
	ClientStreams bool
***REMOVED***

// Stream defines the common interface a client or server stream has to satisfy.
//
// Deprecated: See ClientStream and ServerStream documentation instead.
type Stream interface ***REMOVED***
	// Deprecated: See ClientStream and ServerStream documentation instead.
	Context() context.Context
	// Deprecated: See ClientStream and ServerStream documentation instead.
	SendMsg(m interface***REMOVED******REMOVED***) error
	// Deprecated: See ClientStream and ServerStream documentation instead.
	RecvMsg(m interface***REMOVED******REMOVED***) error
***REMOVED***

// ClientStream defines the client-side behavior of a streaming RPC.
//
// All errors returned from ClientStream methods are compatible with the
// status package.
type ClientStream interface ***REMOVED***
	// Header returns the header metadata received from the server if there
	// is any. It blocks if the metadata is not ready to read.
	Header() (metadata.MD, error)
	// Trailer returns the trailer metadata from the server, if there is any.
	// It must only be called after stream.CloseAndRecv has returned, or
	// stream.Recv has returned a non-nil error (including io.EOF).
	Trailer() metadata.MD
	// CloseSend closes the send direction of the stream. It closes the stream
	// when non-nil error is met. It is also not safe to call CloseSend
	// concurrently with SendMsg.
	CloseSend() error
	// Context returns the context for this stream.
	//
	// It should not be called until after Header or RecvMsg has returned. Once
	// called, subsequent client-side retries are disabled.
	Context() context.Context
	// SendMsg is generally called by generated code. On error, SendMsg aborts
	// the stream. If the error was generated by the client, the status is
	// returned directly; otherwise, io.EOF is returned and the status of
	// the stream may be discovered using RecvMsg.
	//
	// SendMsg blocks until:
	//   - There is sufficient flow control to schedule m with the transport, or
	//   - The stream is done, or
	//   - The stream breaks.
	//
	// SendMsg does not wait until the message is received by the server. An
	// untimely stream closure may result in lost messages. To ensure delivery,
	// users should ensure the RPC completed successfully using RecvMsg.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not safe
	// to call SendMsg on the same stream in different goroutines. It is also
	// not safe to call CloseSend concurrently with SendMsg.
	SendMsg(m interface***REMOVED******REMOVED***) error
	// RecvMsg blocks until it receives a message into m or the stream is
	// done. It returns io.EOF when the stream completes successfully. On
	// any other error, the stream is aborted and the error contains the RPC
	// status.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not
	// safe to call RecvMsg on the same stream in different goroutines.
	RecvMsg(m interface***REMOVED******REMOVED***) error
***REMOVED***

// NewStream creates a new Stream for the client side. This is typically
// called by generated code. ctx is used for the lifetime of the stream.
//
// To ensure resources are not leaked due to the stream returned, one of the following
// actions must be performed:
//
//      1. Call Close on the ClientConn.
//      2. Cancel the context provided.
//      3. Call RecvMsg until a non-nil error is returned. A protobuf-generated
//         client-streaming RPC, for instance, might use the helper function
//         CloseAndRecv (note that CloseSend does not Recv, therefore is not
//         guaranteed to release all resources).
//      4. Receive a non-nil, non-io.EOF error from Header or SendMsg.
//
// If none of the above happen, a goroutine and a context will be leaked, and grpc
// will not call the optionally-configured stats handler with a stats.End message.
func (cc *ClientConn) NewStream(ctx context.Context, desc *StreamDesc, method string, opts ...CallOption) (ClientStream, error) ***REMOVED***
	// allow interceptor to see all applicable call options, which means those
	// configured as defaults from dial option as well as per-call options
	opts = combine(cc.dopts.callOptions, opts)

	if cc.dopts.streamInt != nil ***REMOVED***
		return cc.dopts.streamInt(ctx, desc, cc, method, newClientStream, opts...)
	***REMOVED***
	return newClientStream(ctx, desc, cc, method, opts...)
***REMOVED***

// NewClientStream is a wrapper for ClientConn.NewStream.
func NewClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (ClientStream, error) ***REMOVED***
	return cc.NewStream(ctx, desc, method, opts...)
***REMOVED***

func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) ***REMOVED***
	if channelz.IsOn() ***REMOVED***
		cc.incrCallsStarted()
		defer func() ***REMOVED***
			if err != nil ***REMOVED***
				cc.incrCallsFailed()
			***REMOVED***
		***REMOVED***()
	***REMOVED***
	// Provide an opportunity for the first RPC to see the first service config
	// provided by the resolver.
	if err := cc.waitForResolvedAddrs(ctx); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	var mc serviceconfig.MethodConfig
	var onCommit func()
	var newStream = func(ctx context.Context, done func()) (iresolver.ClientStream, error) ***REMOVED***
		return newClientStreamWithParams(ctx, desc, cc, method, mc, onCommit, done, opts...)
	***REMOVED***

	rpcInfo := iresolver.RPCInfo***REMOVED***Context: ctx, Method: method***REMOVED***
	rpcConfig, err := cc.safeConfigSelector.SelectConfig(rpcInfo)
	if err != nil ***REMOVED***
		return nil, toRPCErr(err)
	***REMOVED***

	if rpcConfig != nil ***REMOVED***
		if rpcConfig.Context != nil ***REMOVED***
			ctx = rpcConfig.Context
		***REMOVED***
		mc = rpcConfig.MethodConfig
		onCommit = rpcConfig.OnCommitted
		if rpcConfig.Interceptor != nil ***REMOVED***
			rpcInfo.Context = nil
			ns := newStream
			newStream = func(ctx context.Context, done func()) (iresolver.ClientStream, error) ***REMOVED***
				cs, err := rpcConfig.Interceptor.NewStream(ctx, rpcInfo, done, ns)
				if err != nil ***REMOVED***
					return nil, toRPCErr(err)
				***REMOVED***
				return cs, nil
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return newStream(ctx, func() ***REMOVED******REMOVED***)
***REMOVED***

func newClientStreamWithParams(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, mc serviceconfig.MethodConfig, onCommit, doneFunc func(), opts ...CallOption) (_ iresolver.ClientStream, err error) ***REMOVED***
	c := defaultCallInfo()
	if mc.WaitForReady != nil ***REMOVED***
		c.failFast = !*mc.WaitForReady
	***REMOVED***

	// Possible context leak:
	// The cancel function for the child context we create will only be called
	// when RecvMsg returns a non-nil error, if the ClientConn is closed, or if
	// an error is generated by SendMsg.
	// https://github.com/grpc/grpc-go/issues/1818.
	var cancel context.CancelFunc
	if mc.Timeout != nil && *mc.Timeout >= 0 ***REMOVED***
		ctx, cancel = context.WithTimeout(ctx, *mc.Timeout)
	***REMOVED*** else ***REMOVED***
		ctx, cancel = context.WithCancel(ctx)
	***REMOVED***
	defer func() ***REMOVED***
		if err != nil ***REMOVED***
			cancel()
		***REMOVED***
	***REMOVED***()

	for _, o := range opts ***REMOVED***
		if err := o.before(c); err != nil ***REMOVED***
			return nil, toRPCErr(err)
		***REMOVED***
	***REMOVED***
	c.maxSendMessageSize = getMaxSize(mc.MaxReqSize, c.maxSendMessageSize, defaultClientMaxSendMessageSize)
	c.maxReceiveMessageSize = getMaxSize(mc.MaxRespSize, c.maxReceiveMessageSize, defaultClientMaxReceiveMessageSize)
	if err := setCallInfoCodec(c); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	callHdr := &transport.CallHdr***REMOVED***
		Host:           cc.authority,
		Method:         method,
		ContentSubtype: c.contentSubtype,
		DoneFunc:       doneFunc,
	***REMOVED***

	// Set our outgoing compression according to the UseCompressor CallOption, if
	// set.  In that case, also find the compressor from the encoding package.
	// Otherwise, use the compressor configured by the WithCompressor DialOption,
	// if set.
	var cp Compressor
	var comp encoding.Compressor
	if ct := c.compressorType; ct != "" ***REMOVED***
		callHdr.SendCompress = ct
		if ct != encoding.Identity ***REMOVED***
			comp = encoding.GetCompressor(ct)
			if comp == nil ***REMOVED***
				return nil, status.Errorf(codes.Internal, "grpc: Compressor is not installed for requested grpc-encoding %q", ct)
			***REMOVED***
		***REMOVED***
	***REMOVED*** else if cc.dopts.cp != nil ***REMOVED***
		callHdr.SendCompress = cc.dopts.cp.Type()
		cp = cc.dopts.cp
	***REMOVED***
	if c.creds != nil ***REMOVED***
		callHdr.Creds = c.creds
	***REMOVED***
	var trInfo *traceInfo
	if EnableTracing ***REMOVED***
		trInfo = &traceInfo***REMOVED***
			tr: trace.New("grpc.Sent."+methodFamily(method), method),
			firstLine: firstLine***REMOVED***
				client: true,
			***REMOVED***,
		***REMOVED***
		if deadline, ok := ctx.Deadline(); ok ***REMOVED***
			trInfo.firstLine.deadline = time.Until(deadline)
		***REMOVED***
		trInfo.tr.LazyLog(&trInfo.firstLine, false)
		ctx = trace.NewContext(ctx, trInfo.tr)
	***REMOVED***
	ctx = newContextWithRPCInfo(ctx, c.failFast, c.codec, cp, comp)
	sh := cc.dopts.copts.StatsHandler
	var beginTime time.Time
	if sh != nil ***REMOVED***
		ctx = sh.TagRPC(ctx, &stats.RPCTagInfo***REMOVED***FullMethodName: method, FailFast: c.failFast***REMOVED***)
		beginTime = time.Now()
		begin := &stats.Begin***REMOVED***
			Client:    true,
			BeginTime: beginTime,
			FailFast:  c.failFast,
		***REMOVED***
		sh.HandleRPC(ctx, begin)
	***REMOVED***

	cs := &clientStream***REMOVED***
		callHdr:      callHdr,
		ctx:          ctx,
		methodConfig: &mc,
		opts:         opts,
		callInfo:     c,
		cc:           cc,
		desc:         desc,
		codec:        c.codec,
		cp:           cp,
		comp:         comp,
		cancel:       cancel,
		beginTime:    beginTime,
		firstAttempt: true,
		onCommit:     onCommit,
	***REMOVED***
	if !cc.dopts.disableRetry ***REMOVED***
		cs.retryThrottler = cc.retryThrottler.Load().(*retryThrottler)
	***REMOVED***
	cs.binlog = binarylog.GetMethodLogger(method)

	// Only this initial attempt has stats/tracing.
	// TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
	if err := cs.newAttemptLocked(sh, trInfo); err != nil ***REMOVED***
		cs.finish(err)
		return nil, err
	***REMOVED***

	op := func(a *csAttempt) error ***REMOVED*** return a.newStream() ***REMOVED***
	if err := cs.withRetry(op, func() ***REMOVED*** cs.bufferForRetryLocked(0, op) ***REMOVED***); err != nil ***REMOVED***
		cs.finish(err)
		return nil, err
	***REMOVED***

	if cs.binlog != nil ***REMOVED***
		md, _ := metadata.FromOutgoingContext(ctx)
		logEntry := &binarylog.ClientHeader***REMOVED***
			OnClientSide: true,
			Header:       md,
			MethodName:   method,
			Authority:    cs.cc.authority,
		***REMOVED***
		if deadline, ok := ctx.Deadline(); ok ***REMOVED***
			logEntry.Timeout = time.Until(deadline)
			if logEntry.Timeout < 0 ***REMOVED***
				logEntry.Timeout = 0
			***REMOVED***
		***REMOVED***
		cs.binlog.Log(logEntry)
	***REMOVED***

	if desc != unaryStreamDesc ***REMOVED***
		// Listen on cc and stream contexts to cleanup when the user closes the
		// ClientConn or cancels the stream context.  In all other cases, an error
		// should already be injected into the recv buffer by the transport, which
		// the client will eventually receive, and then we will cancel the stream's
		// context in clientStream.finish.
		go func() ***REMOVED***
			select ***REMOVED***
			case <-cc.ctx.Done():
				cs.finish(ErrClientConnClosing)
			case <-ctx.Done():
				cs.finish(toRPCErr(ctx.Err()))
			***REMOVED***
		***REMOVED***()
	***REMOVED***
	return cs, nil
***REMOVED***

// newAttemptLocked creates a new attempt with a transport.
// If it succeeds, then it replaces clientStream's attempt with this new attempt.
func (cs *clientStream) newAttemptLocked(sh stats.Handler, trInfo *traceInfo) (retErr error) ***REMOVED***
	newAttempt := &csAttempt***REMOVED***
		cs:           cs,
		dc:           cs.cc.dopts.dc,
		statsHandler: sh,
		trInfo:       trInfo,
	***REMOVED***
	defer func() ***REMOVED***
		if retErr != nil ***REMOVED***
			// This attempt is not set in the clientStream, so it's finish won't
			// be called. Call it here for stats and trace in case they are not
			// nil.
			newAttempt.finish(retErr)
		***REMOVED***
	***REMOVED***()

	if err := cs.ctx.Err(); err != nil ***REMOVED***
		return toRPCErr(err)
	***REMOVED***

	ctx := cs.ctx
	if cs.cc.parsedTarget.Scheme == "xds" ***REMOVED***
		// Add extra metadata (metadata that will be added by transport) to context
		// so the balancer can see them.
		ctx = grpcutil.WithExtraMetadata(cs.ctx, metadata.Pairs(
			"content-type", grpcutil.ContentType(cs.callHdr.ContentSubtype),
		))
	***REMOVED***
	t, done, err := cs.cc.getTransport(ctx, cs.callInfo.failFast, cs.callHdr.Method)
	if err != nil ***REMOVED***
		return err
	***REMOVED***
	if trInfo != nil ***REMOVED***
		trInfo.firstLine.SetRemoteAddr(t.RemoteAddr())
	***REMOVED***
	newAttempt.t = t
	newAttempt.done = done
	cs.attempt = newAttempt
	return nil
***REMOVED***

func (a *csAttempt) newStream() error ***REMOVED***
	cs := a.cs
	cs.callHdr.PreviousAttempts = cs.numRetries
	s, err := a.t.NewStream(cs.ctx, cs.callHdr)
	if err != nil ***REMOVED***
		if _, ok := err.(transport.PerformedIOError); ok ***REMOVED***
			// Return without converting to an RPC error so retry code can
			// inspect.
			return err
		***REMOVED***
		return toRPCErr(err)
	***REMOVED***
	cs.attempt.s = s
	cs.attempt.p = &parser***REMOVED***r: s***REMOVED***
	return nil
***REMOVED***

// clientStream implements a client side Stream.
type clientStream struct ***REMOVED***
	callHdr  *transport.CallHdr
	opts     []CallOption
	callInfo *callInfo
	cc       *ClientConn
	desc     *StreamDesc

	codec baseCodec
	cp    Compressor
	comp  encoding.Compressor

	cancel context.CancelFunc // cancels all attempts

	sentLast  bool // sent an end stream
	beginTime time.Time

	methodConfig *MethodConfig

	ctx context.Context // the application's context, wrapped by stats/tracing

	retryThrottler *retryThrottler // The throttler active when the RPC began.

	binlog *binarylog.MethodLogger // Binary logger, can be nil.
	// serverHeaderBinlogged is a boolean for whether server header has been
	// logged. Server header will be logged when the first time one of those
	// happens: stream.Header(), stream.Recv().
	//
	// It's only read and used by Recv() and Header(), so it doesn't need to be
	// synchronized.
	serverHeaderBinlogged bool

	mu                      sync.Mutex
	firstAttempt            bool // if true, transparent retry is valid
	numRetries              int  // exclusive of transparent retry attempt(s)
	numRetriesSincePushback int  // retries since pushback; to reset backoff
	finished                bool // TODO: replace with atomic cmpxchg or sync.Once?
	// attempt is the active client stream attempt.
	// The only place where it is written is the newAttemptLocked method and this method never writes nil.
	// So, attempt can be nil only inside newClientStream function when clientStream is first created.
	// One of the first things done after clientStream's creation, is to call newAttemptLocked which either
	// assigns a non nil value to the attempt or returns an error. If an error is returned from newAttemptLocked,
	// then newClientStream calls finish on the clientStream and returns. So, finish method is the only
	// place where we need to check if the attempt is nil.
	attempt *csAttempt
	// TODO(hedging): hedging will have multiple attempts simultaneously.
	committed  bool // active attempt committed for retry?
	onCommit   func()
	buffer     []func(a *csAttempt) error // operations to replay on retry
	bufferSize int                        // current size of buffer
***REMOVED***

// csAttempt implements a single transport stream attempt within a
// clientStream.
type csAttempt struct ***REMOVED***
	cs   *clientStream
	t    transport.ClientTransport
	s    *transport.Stream
	p    *parser
	done func(balancer.DoneInfo)

	finished  bool
	dc        Decompressor
	decomp    encoding.Compressor
	decompSet bool

	mu sync.Mutex // guards trInfo.tr
	// trInfo may be nil (if EnableTracing is false).
	// trInfo.tr is set when created (if EnableTracing is true),
	// and cleared when the finish method is called.
	trInfo *traceInfo

	statsHandler stats.Handler
***REMOVED***

func (cs *clientStream) commitAttemptLocked() ***REMOVED***
	if !cs.committed && cs.onCommit != nil ***REMOVED***
		cs.onCommit()
	***REMOVED***
	cs.committed = true
	cs.buffer = nil
***REMOVED***

func (cs *clientStream) commitAttempt() ***REMOVED***
	cs.mu.Lock()
	cs.commitAttemptLocked()
	cs.mu.Unlock()
***REMOVED***

// shouldRetry returns nil if the RPC should be retried; otherwise it returns
// the error that should be returned by the operation.
func (cs *clientStream) shouldRetry(err error) error ***REMOVED***
	unprocessed := false
	if cs.attempt.s == nil ***REMOVED***
		pioErr, ok := err.(transport.PerformedIOError)
		if ok ***REMOVED***
			// Unwrap error.
			err = toRPCErr(pioErr.Err)
		***REMOVED*** else ***REMOVED***
			unprocessed = true
		***REMOVED***
		if !ok && !cs.callInfo.failFast ***REMOVED***
			// In the event of a non-IO operation error from NewStream, we
			// never attempted to write anything to the wire, so we can retry
			// indefinitely for non-fail-fast RPCs.
			return nil
		***REMOVED***
	***REMOVED***
	if cs.finished || cs.committed ***REMOVED***
		// RPC is finished or committed; cannot retry.
		return err
	***REMOVED***
	// Wait for the trailers.
	if cs.attempt.s != nil ***REMOVED***
		<-cs.attempt.s.Done()
		unprocessed = cs.attempt.s.Unprocessed()
	***REMOVED***
	if cs.firstAttempt && unprocessed ***REMOVED***
		// First attempt, stream unprocessed: transparently retry.
		return nil
	***REMOVED***
	if cs.cc.dopts.disableRetry ***REMOVED***
		return err
	***REMOVED***

	pushback := 0
	hasPushback := false
	if cs.attempt.s != nil ***REMOVED***
		if !cs.attempt.s.TrailersOnly() ***REMOVED***
			return err
		***REMOVED***

		// TODO(retry): Move down if the spec changes to not check server pushback
		// before considering this a failure for throttling.
		sps := cs.attempt.s.Trailer()["grpc-retry-pushback-ms"]
		if len(sps) == 1 ***REMOVED***
			var e error
			if pushback, e = strconv.Atoi(sps[0]); e != nil || pushback < 0 ***REMOVED***
				channelz.Infof(logger, cs.cc.channelzID, "Server retry pushback specified to abort (%q).", sps[0])
				cs.retryThrottler.throttle() // This counts as a failure for throttling.
				return err
			***REMOVED***
			hasPushback = true
		***REMOVED*** else if len(sps) > 1 ***REMOVED***
			channelz.Warningf(logger, cs.cc.channelzID, "Server retry pushback specified multiple values (%q); not retrying.", sps)
			cs.retryThrottler.throttle() // This counts as a failure for throttling.
			return err
		***REMOVED***
	***REMOVED***

	var code codes.Code
	if cs.attempt.s != nil ***REMOVED***
		code = cs.attempt.s.Status().Code()
	***REMOVED*** else ***REMOVED***
		code = status.Convert(err).Code()
	***REMOVED***

	rp := cs.methodConfig.RetryPolicy
	if rp == nil || !rp.RetryableStatusCodes[code] ***REMOVED***
		return err
	***REMOVED***

	// Note: the ordering here is important; we count this as a failure
	// only if the code matched a retryable code.
	if cs.retryThrottler.throttle() ***REMOVED***
		return err
	***REMOVED***
	if cs.numRetries+1 >= rp.MaxAttempts ***REMOVED***
		return err
	***REMOVED***

	var dur time.Duration
	if hasPushback ***REMOVED***
		dur = time.Millisecond * time.Duration(pushback)
		cs.numRetriesSincePushback = 0
	***REMOVED*** else ***REMOVED***
		fact := math.Pow(rp.BackoffMultiplier, float64(cs.numRetriesSincePushback))
		cur := float64(rp.InitialBackoff) * fact
		if max := float64(rp.MaxBackoff); cur > max ***REMOVED***
			cur = max
		***REMOVED***
		dur = time.Duration(grpcrand.Int63n(int64(cur)))
		cs.numRetriesSincePushback++
	***REMOVED***

	// TODO(dfawley): we could eagerly fail here if dur puts us past the
	// deadline, but unsure if it is worth doing.
	t := time.NewTimer(dur)
	select ***REMOVED***
	case <-t.C:
		cs.numRetries++
		return nil
	case <-cs.ctx.Done():
		t.Stop()
		return status.FromContextError(cs.ctx.Err()).Err()
	***REMOVED***
***REMOVED***

// Returns nil if a retry was performed and succeeded; error otherwise.
func (cs *clientStream) retryLocked(lastErr error) error ***REMOVED***
	for ***REMOVED***
		cs.attempt.finish(lastErr)
		if err := cs.shouldRetry(lastErr); err != nil ***REMOVED***
			cs.commitAttemptLocked()
			return err
		***REMOVED***
		cs.firstAttempt = false
		if err := cs.newAttemptLocked(nil, nil); err != nil ***REMOVED***
			return err
		***REMOVED***
		if lastErr = cs.replayBufferLocked(); lastErr == nil ***REMOVED***
			return nil
		***REMOVED***
	***REMOVED***
***REMOVED***

func (cs *clientStream) Context() context.Context ***REMOVED***
	cs.commitAttempt()
	// No need to lock before using attempt, since we know it is committed and
	// cannot change.
	return cs.attempt.s.Context()
***REMOVED***

func (cs *clientStream) withRetry(op func(a *csAttempt) error, onSuccess func()) error ***REMOVED***
	cs.mu.Lock()
	for ***REMOVED***
		if cs.committed ***REMOVED***
			cs.mu.Unlock()
			return op(cs.attempt)
		***REMOVED***
		a := cs.attempt
		cs.mu.Unlock()
		err := op(a)
		cs.mu.Lock()
		if a != cs.attempt ***REMOVED***
			// We started another attempt already.
			continue
		***REMOVED***
		if err == io.EOF ***REMOVED***
			<-a.s.Done()
		***REMOVED***
		if err == nil || (err == io.EOF && a.s.Status().Code() == codes.OK) ***REMOVED***
			onSuccess()
			cs.mu.Unlock()
			return err
		***REMOVED***
		if err := cs.retryLocked(err); err != nil ***REMOVED***
			cs.mu.Unlock()
			return err
		***REMOVED***
	***REMOVED***
***REMOVED***

func (cs *clientStream) Header() (metadata.MD, error) ***REMOVED***
	var m metadata.MD
	err := cs.withRetry(func(a *csAttempt) error ***REMOVED***
		var err error
		m, err = a.s.Header()
		return toRPCErr(err)
	***REMOVED***, cs.commitAttemptLocked)
	if err != nil ***REMOVED***
		cs.finish(err)
		return nil, err
	***REMOVED***
	if cs.binlog != nil && !cs.serverHeaderBinlogged ***REMOVED***
		// Only log if binary log is on and header has not been logged.
		logEntry := &binarylog.ServerHeader***REMOVED***
			OnClientSide: true,
			Header:       m,
			PeerAddr:     nil,
		***REMOVED***
		if peer, ok := peer.FromContext(cs.Context()); ok ***REMOVED***
			logEntry.PeerAddr = peer.Addr
		***REMOVED***
		cs.binlog.Log(logEntry)
		cs.serverHeaderBinlogged = true
	***REMOVED***
	return m, err
***REMOVED***

func (cs *clientStream) Trailer() metadata.MD ***REMOVED***
	// On RPC failure, we never need to retry, because usage requires that
	// RecvMsg() returned a non-nil error before calling this function is valid.
	// We would have retried earlier if necessary.
	//
	// Commit the attempt anyway, just in case users are not following those
	// directions -- it will prevent races and should not meaningfully impact
	// performance.
	cs.commitAttempt()
	if cs.attempt.s == nil ***REMOVED***
		return nil
	***REMOVED***
	return cs.attempt.s.Trailer()
***REMOVED***

func (cs *clientStream) replayBufferLocked() error ***REMOVED***
	a := cs.attempt
	for _, f := range cs.buffer ***REMOVED***
		if err := f(a); err != nil ***REMOVED***
			return err
		***REMOVED***
	***REMOVED***
	return nil
***REMOVED***

func (cs *clientStream) bufferForRetryLocked(sz int, op func(a *csAttempt) error) ***REMOVED***
	// Note: we still will buffer if retry is disabled (for transparent retries).
	if cs.committed ***REMOVED***
		return
	***REMOVED***
	cs.bufferSize += sz
	if cs.bufferSize > cs.callInfo.maxRetryRPCBufferSize ***REMOVED***
		cs.commitAttemptLocked()
		return
	***REMOVED***
	cs.buffer = append(cs.buffer, op)
***REMOVED***

func (cs *clientStream) SendMsg(m interface***REMOVED******REMOVED***) (err error) ***REMOVED***
	defer func() ***REMOVED***
		if err != nil && err != io.EOF ***REMOVED***
			// Call finish on the client stream for errors generated by this SendMsg
			// call, as these indicate problems created by this client.  (Transport
			// errors are converted to an io.EOF error in csAttempt.sendMsg; the real
			// error will be returned from RecvMsg eventually in that case, or be
			// retried.)
			cs.finish(err)
		***REMOVED***
	***REMOVED***()
	if cs.sentLast ***REMOVED***
		return status.Errorf(codes.Internal, "SendMsg called after CloseSend")
	***REMOVED***
	if !cs.desc.ClientStreams ***REMOVED***
		cs.sentLast = true
	***REMOVED***

	// load hdr, payload, data
	hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	// TODO(dfawley): should we be checking len(data) instead?
	if len(payload) > *cs.callInfo.maxSendMessageSize ***REMOVED***
		return status.Errorf(codes.ResourceExhausted, "trying to send message larger than max (%d vs. %d)", len(payload), *cs.callInfo.maxSendMessageSize)
	***REMOVED***
	msgBytes := data // Store the pointer before setting to nil. For binary logging.
	op := func(a *csAttempt) error ***REMOVED***
		err := a.sendMsg(m, hdr, payload, data)
		// nil out the message and uncomp when replaying; they are only needed for
		// stats which is disabled for subsequent attempts.
		m, data = nil, nil
		return err
	***REMOVED***
	err = cs.withRetry(op, func() ***REMOVED*** cs.bufferForRetryLocked(len(hdr)+len(payload), op) ***REMOVED***)
	if cs.binlog != nil && err == nil ***REMOVED***
		cs.binlog.Log(&binarylog.ClientMessage***REMOVED***
			OnClientSide: true,
			Message:      msgBytes,
		***REMOVED***)
	***REMOVED***
	return
***REMOVED***

func (cs *clientStream) RecvMsg(m interface***REMOVED******REMOVED***) error ***REMOVED***
	if cs.binlog != nil && !cs.serverHeaderBinlogged ***REMOVED***
		// Call Header() to binary log header if it's not already logged.
		cs.Header()
	***REMOVED***
	var recvInfo *payloadInfo
	if cs.binlog != nil ***REMOVED***
		recvInfo = &payloadInfo***REMOVED******REMOVED***
	***REMOVED***
	err := cs.withRetry(func(a *csAttempt) error ***REMOVED***
		return a.recvMsg(m, recvInfo)
	***REMOVED***, cs.commitAttemptLocked)
	if cs.binlog != nil && err == nil ***REMOVED***
		cs.binlog.Log(&binarylog.ServerMessage***REMOVED***
			OnClientSide: true,
			Message:      recvInfo.uncompressedBytes,
		***REMOVED***)
	***REMOVED***
	if err != nil || !cs.desc.ServerStreams ***REMOVED***
		// err != nil or non-server-streaming indicates end of stream.
		cs.finish(err)

		if cs.binlog != nil ***REMOVED***
			// finish will not log Trailer. Log Trailer here.
			logEntry := &binarylog.ServerTrailer***REMOVED***
				OnClientSide: true,
				Trailer:      cs.Trailer(),
				Err:          err,
			***REMOVED***
			if logEntry.Err == io.EOF ***REMOVED***
				logEntry.Err = nil
			***REMOVED***
			if peer, ok := peer.FromContext(cs.Context()); ok ***REMOVED***
				logEntry.PeerAddr = peer.Addr
			***REMOVED***
			cs.binlog.Log(logEntry)
		***REMOVED***
	***REMOVED***
	return err
***REMOVED***

func (cs *clientStream) CloseSend() error ***REMOVED***
	if cs.sentLast ***REMOVED***
		// TODO: return an error and finish the stream instead, due to API misuse?
		return nil
	***REMOVED***
	cs.sentLast = true
	op := func(a *csAttempt) error ***REMOVED***
		a.t.Write(a.s, nil, nil, &transport.Options***REMOVED***Last: true***REMOVED***)
		// Always return nil; io.EOF is the only error that might make sense
		// instead, but there is no need to signal the client to call RecvMsg
		// as the only use left for the stream after CloseSend is to call
		// RecvMsg.  This also matches historical behavior.
		return nil
	***REMOVED***
	cs.withRetry(op, func() ***REMOVED*** cs.bufferForRetryLocked(0, op) ***REMOVED***)
	if cs.binlog != nil ***REMOVED***
		cs.binlog.Log(&binarylog.ClientHalfClose***REMOVED***
			OnClientSide: true,
		***REMOVED***)
	***REMOVED***
	// We never returned an error here for reasons.
	return nil
***REMOVED***

func (cs *clientStream) finish(err error) ***REMOVED***
	if err == io.EOF ***REMOVED***
		// Ending a stream with EOF indicates a success.
		err = nil
	***REMOVED***
	cs.mu.Lock()
	if cs.finished ***REMOVED***
		cs.mu.Unlock()
		return
	***REMOVED***
	cs.finished = true
	cs.commitAttemptLocked()
	if cs.attempt != nil ***REMOVED***
		cs.attempt.finish(err)
		// after functions all rely upon having a stream.
		if cs.attempt.s != nil ***REMOVED***
			for _, o := range cs.opts ***REMOVED***
				o.after(cs.callInfo, cs.attempt)
			***REMOVED***
		***REMOVED***
	***REMOVED***
	cs.mu.Unlock()
	// For binary logging. only log cancel in finish (could be caused by RPC ctx
	// canceled or ClientConn closed). Trailer will be logged in RecvMsg.
	//
	// Only one of cancel or trailer needs to be logged. In the cases where
	// users don't call RecvMsg, users must have already canceled the RPC.
	if cs.binlog != nil && status.Code(err) == codes.Canceled ***REMOVED***
		cs.binlog.Log(&binarylog.Cancel***REMOVED***
			OnClientSide: true,
		***REMOVED***)
	***REMOVED***
	if err == nil ***REMOVED***
		cs.retryThrottler.successfulRPC()
	***REMOVED***
	if channelz.IsOn() ***REMOVED***
		if err != nil ***REMOVED***
			cs.cc.incrCallsFailed()
		***REMOVED*** else ***REMOVED***
			cs.cc.incrCallsSucceeded()
		***REMOVED***
	***REMOVED***
	cs.cancel()
***REMOVED***

func (a *csAttempt) sendMsg(m interface***REMOVED******REMOVED***, hdr, payld, data []byte) error ***REMOVED***
	cs := a.cs
	if a.trInfo != nil ***REMOVED***
		a.mu.Lock()
		if a.trInfo.tr != nil ***REMOVED***
			a.trInfo.tr.LazyLog(&payload***REMOVED***sent: true, msg: m***REMOVED***, true)
		***REMOVED***
		a.mu.Unlock()
	***REMOVED***
	if err := a.t.Write(a.s, hdr, payld, &transport.Options***REMOVED***Last: !cs.desc.ClientStreams***REMOVED***); err != nil ***REMOVED***
		if !cs.desc.ClientStreams ***REMOVED***
			// For non-client-streaming RPCs, we return nil instead of EOF on error
			// because the generated code requires it.  finish is not called; RecvMsg()
			// will call it with the stream's status independently.
			return nil
		***REMOVED***
		return io.EOF
	***REMOVED***
	if a.statsHandler != nil ***REMOVED***
		a.statsHandler.HandleRPC(cs.ctx, outPayload(true, m, data, payld, time.Now()))
	***REMOVED***
	if channelz.IsOn() ***REMOVED***
		a.t.IncrMsgSent()
	***REMOVED***
	return nil
***REMOVED***

func (a *csAttempt) recvMsg(m interface***REMOVED******REMOVED***, payInfo *payloadInfo) (err error) ***REMOVED***
	cs := a.cs
	if a.statsHandler != nil && payInfo == nil ***REMOVED***
		payInfo = &payloadInfo***REMOVED******REMOVED***
	***REMOVED***

	if !a.decompSet ***REMOVED***
		// Block until we receive headers containing received message encoding.
		if ct := a.s.RecvCompress(); ct != "" && ct != encoding.Identity ***REMOVED***
			if a.dc == nil || a.dc.Type() != ct ***REMOVED***
				// No configured decompressor, or it does not match the incoming
				// message encoding; attempt to find a registered compressor that does.
				a.dc = nil
				a.decomp = encoding.GetCompressor(ct)
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			// No compression is used; disable our decompressor.
			a.dc = nil
		***REMOVED***
		// Only initialize this state once per stream.
		a.decompSet = true
	***REMOVED***
	err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, payInfo, a.decomp)
	if err != nil ***REMOVED***
		if err == io.EOF ***REMOVED***
			if statusErr := a.s.Status().Err(); statusErr != nil ***REMOVED***
				return statusErr
			***REMOVED***
			return io.EOF // indicates successful end of stream.
		***REMOVED***
		return toRPCErr(err)
	***REMOVED***
	if a.trInfo != nil ***REMOVED***
		a.mu.Lock()
		if a.trInfo.tr != nil ***REMOVED***
			a.trInfo.tr.LazyLog(&payload***REMOVED***sent: false, msg: m***REMOVED***, true)
		***REMOVED***
		a.mu.Unlock()
	***REMOVED***
	if a.statsHandler != nil ***REMOVED***
		a.statsHandler.HandleRPC(cs.ctx, &stats.InPayload***REMOVED***
			Client:   true,
			RecvTime: time.Now(),
			Payload:  m,
			// TODO truncate large payload.
			Data:       payInfo.uncompressedBytes,
			WireLength: payInfo.wireLength + headerLen,
			Length:     len(payInfo.uncompressedBytes),
		***REMOVED***)
	***REMOVED***
	if channelz.IsOn() ***REMOVED***
		a.t.IncrMsgRecv()
	***REMOVED***
	if cs.desc.ServerStreams ***REMOVED***
		// Subsequent messages should be received by subsequent RecvMsg calls.
		return nil
	***REMOVED***
	// Special handling for non-server-stream rpcs.
	// This recv expects EOF or errors, so we don't collect inPayload.
	err = recv(a.p, cs.codec, a.s, a.dc, m, *cs.callInfo.maxReceiveMessageSize, nil, a.decomp)
	if err == nil ***REMOVED***
		return toRPCErr(errors.New("grpc: client streaming protocol violation: get <nil>, want <EOF>"))
	***REMOVED***
	if err == io.EOF ***REMOVED***
		return a.s.Status().Err() // non-server streaming Recv returns nil on success
	***REMOVED***
	return toRPCErr(err)
***REMOVED***

func (a *csAttempt) finish(err error) ***REMOVED***
	a.mu.Lock()
	if a.finished ***REMOVED***
		a.mu.Unlock()
		return
	***REMOVED***
	a.finished = true
	if err == io.EOF ***REMOVED***
		// Ending a stream with EOF indicates a success.
		err = nil
	***REMOVED***
	var tr metadata.MD
	if a.s != nil ***REMOVED***
		a.t.CloseStream(a.s, err)
		tr = a.s.Trailer()
	***REMOVED***

	if a.done != nil ***REMOVED***
		br := false
		if a.s != nil ***REMOVED***
			br = a.s.BytesReceived()
		***REMOVED***
		a.done(balancer.DoneInfo***REMOVED***
			Err:           err,
			Trailer:       tr,
			BytesSent:     a.s != nil,
			BytesReceived: br,
			ServerLoad:    balancerload.Parse(tr),
		***REMOVED***)
	***REMOVED***
	if a.statsHandler != nil ***REMOVED***
		end := &stats.End***REMOVED***
			Client:    true,
			BeginTime: a.cs.beginTime,
			EndTime:   time.Now(),
			Trailer:   tr,
			Error:     err,
		***REMOVED***
		a.statsHandler.HandleRPC(a.cs.ctx, end)
	***REMOVED***
	if a.trInfo != nil && a.trInfo.tr != nil ***REMOVED***
		if err == nil ***REMOVED***
			a.trInfo.tr.LazyPrintf("RPC: [OK]")
		***REMOVED*** else ***REMOVED***
			a.trInfo.tr.LazyPrintf("RPC: [%v]", err)
			a.trInfo.tr.SetError()
		***REMOVED***
		a.trInfo.tr.Finish()
		a.trInfo.tr = nil
	***REMOVED***
	a.mu.Unlock()
***REMOVED***

// newClientStream creates a ClientStream with the specified transport, on the
// given addrConn.
//
// It's expected that the given transport is either the same one in addrConn, or
// is already closed. To avoid race, transport is specified separately, instead
// of using ac.transpot.
//
// Main difference between this and ClientConn.NewStream:
// - no retry
// - no service config (or wait for service config)
// - no tracing or stats
func newNonRetryClientStream(ctx context.Context, desc *StreamDesc, method string, t transport.ClientTransport, ac *addrConn, opts ...CallOption) (_ ClientStream, err error) ***REMOVED***
	if t == nil ***REMOVED***
		// TODO: return RPC error here?
		return nil, errors.New("transport provided is nil")
	***REMOVED***
	// defaultCallInfo contains unnecessary info(i.e. failfast, maxRetryRPCBufferSize), so we just initialize an empty struct.
	c := &callInfo***REMOVED******REMOVED***

	// Possible context leak:
	// The cancel function for the child context we create will only be called
	// when RecvMsg returns a non-nil error, if the ClientConn is closed, or if
	// an error is generated by SendMsg.
	// https://github.com/grpc/grpc-go/issues/1818.
	ctx, cancel := context.WithCancel(ctx)
	defer func() ***REMOVED***
		if err != nil ***REMOVED***
			cancel()
		***REMOVED***
	***REMOVED***()

	for _, o := range opts ***REMOVED***
		if err := o.before(c); err != nil ***REMOVED***
			return nil, toRPCErr(err)
		***REMOVED***
	***REMOVED***
	c.maxReceiveMessageSize = getMaxSize(nil, c.maxReceiveMessageSize, defaultClientMaxReceiveMessageSize)
	c.maxSendMessageSize = getMaxSize(nil, c.maxSendMessageSize, defaultServerMaxSendMessageSize)
	if err := setCallInfoCodec(c); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	callHdr := &transport.CallHdr***REMOVED***
		Host:           ac.cc.authority,
		Method:         method,
		ContentSubtype: c.contentSubtype,
	***REMOVED***

	// Set our outgoing compression according to the UseCompressor CallOption, if
	// set.  In that case, also find the compressor from the encoding package.
	// Otherwise, use the compressor configured by the WithCompressor DialOption,
	// if set.
	var cp Compressor
	var comp encoding.Compressor
	if ct := c.compressorType; ct != "" ***REMOVED***
		callHdr.SendCompress = ct
		if ct != encoding.Identity ***REMOVED***
			comp = encoding.GetCompressor(ct)
			if comp == nil ***REMOVED***
				return nil, status.Errorf(codes.Internal, "grpc: Compressor is not installed for requested grpc-encoding %q", ct)
			***REMOVED***
		***REMOVED***
	***REMOVED*** else if ac.cc.dopts.cp != nil ***REMOVED***
		callHdr.SendCompress = ac.cc.dopts.cp.Type()
		cp = ac.cc.dopts.cp
	***REMOVED***
	if c.creds != nil ***REMOVED***
		callHdr.Creds = c.creds
	***REMOVED***

	// Use a special addrConnStream to avoid retry.
	as := &addrConnStream***REMOVED***
		callHdr:  callHdr,
		ac:       ac,
		ctx:      ctx,
		cancel:   cancel,
		opts:     opts,
		callInfo: c,
		desc:     desc,
		codec:    c.codec,
		cp:       cp,
		comp:     comp,
		t:        t,
	***REMOVED***

	s, err := as.t.NewStream(as.ctx, as.callHdr)
	if err != nil ***REMOVED***
		err = toRPCErr(err)
		return nil, err
	***REMOVED***
	as.s = s
	as.p = &parser***REMOVED***r: s***REMOVED***
	ac.incrCallsStarted()
	if desc != unaryStreamDesc ***REMOVED***
		// Listen on cc and stream contexts to cleanup when the user closes the
		// ClientConn or cancels the stream context.  In all other cases, an error
		// should already be injected into the recv buffer by the transport, which
		// the client will eventually receive, and then we will cancel the stream's
		// context in clientStream.finish.
		go func() ***REMOVED***
			select ***REMOVED***
			case <-ac.ctx.Done():
				as.finish(status.Error(codes.Canceled, "grpc: the SubConn is closing"))
			case <-ctx.Done():
				as.finish(toRPCErr(ctx.Err()))
			***REMOVED***
		***REMOVED***()
	***REMOVED***
	return as, nil
***REMOVED***

type addrConnStream struct ***REMOVED***
	s         *transport.Stream
	ac        *addrConn
	callHdr   *transport.CallHdr
	cancel    context.CancelFunc
	opts      []CallOption
	callInfo  *callInfo
	t         transport.ClientTransport
	ctx       context.Context
	sentLast  bool
	desc      *StreamDesc
	codec     baseCodec
	cp        Compressor
	comp      encoding.Compressor
	decompSet bool
	dc        Decompressor
	decomp    encoding.Compressor
	p         *parser
	mu        sync.Mutex
	finished  bool
***REMOVED***

func (as *addrConnStream) Header() (metadata.MD, error) ***REMOVED***
	m, err := as.s.Header()
	if err != nil ***REMOVED***
		as.finish(toRPCErr(err))
	***REMOVED***
	return m, err
***REMOVED***

func (as *addrConnStream) Trailer() metadata.MD ***REMOVED***
	return as.s.Trailer()
***REMOVED***

func (as *addrConnStream) CloseSend() error ***REMOVED***
	if as.sentLast ***REMOVED***
		// TODO: return an error and finish the stream instead, due to API misuse?
		return nil
	***REMOVED***
	as.sentLast = true

	as.t.Write(as.s, nil, nil, &transport.Options***REMOVED***Last: true***REMOVED***)
	// Always return nil; io.EOF is the only error that might make sense
	// instead, but there is no need to signal the client to call RecvMsg
	// as the only use left for the stream after CloseSend is to call
	// RecvMsg.  This also matches historical behavior.
	return nil
***REMOVED***

func (as *addrConnStream) Context() context.Context ***REMOVED***
	return as.s.Context()
***REMOVED***

func (as *addrConnStream) SendMsg(m interface***REMOVED******REMOVED***) (err error) ***REMOVED***
	defer func() ***REMOVED***
		if err != nil && err != io.EOF ***REMOVED***
			// Call finish on the client stream for errors generated by this SendMsg
			// call, as these indicate problems created by this client.  (Transport
			// errors are converted to an io.EOF error in csAttempt.sendMsg; the real
			// error will be returned from RecvMsg eventually in that case, or be
			// retried.)
			as.finish(err)
		***REMOVED***
	***REMOVED***()
	if as.sentLast ***REMOVED***
		return status.Errorf(codes.Internal, "SendMsg called after CloseSend")
	***REMOVED***
	if !as.desc.ClientStreams ***REMOVED***
		as.sentLast = true
	***REMOVED***

	// load hdr, payload, data
	hdr, payld, _, err := prepareMsg(m, as.codec, as.cp, as.comp)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	// TODO(dfawley): should we be checking len(data) instead?
	if len(payld) > *as.callInfo.maxSendMessageSize ***REMOVED***
		return status.Errorf(codes.ResourceExhausted, "trying to send message larger than max (%d vs. %d)", len(payld), *as.callInfo.maxSendMessageSize)
	***REMOVED***

	if err := as.t.Write(as.s, hdr, payld, &transport.Options***REMOVED***Last: !as.desc.ClientStreams***REMOVED***); err != nil ***REMOVED***
		if !as.desc.ClientStreams ***REMOVED***
			// For non-client-streaming RPCs, we return nil instead of EOF on error
			// because the generated code requires it.  finish is not called; RecvMsg()
			// will call it with the stream's status independently.
			return nil
		***REMOVED***
		return io.EOF
	***REMOVED***

	if channelz.IsOn() ***REMOVED***
		as.t.IncrMsgSent()
	***REMOVED***
	return nil
***REMOVED***

func (as *addrConnStream) RecvMsg(m interface***REMOVED******REMOVED***) (err error) ***REMOVED***
	defer func() ***REMOVED***
		if err != nil || !as.desc.ServerStreams ***REMOVED***
			// err != nil or non-server-streaming indicates end of stream.
			as.finish(err)
		***REMOVED***
	***REMOVED***()

	if !as.decompSet ***REMOVED***
		// Block until we receive headers containing received message encoding.
		if ct := as.s.RecvCompress(); ct != "" && ct != encoding.Identity ***REMOVED***
			if as.dc == nil || as.dc.Type() != ct ***REMOVED***
				// No configured decompressor, or it does not match the incoming
				// message encoding; attempt to find a registered compressor that does.
				as.dc = nil
				as.decomp = encoding.GetCompressor(ct)
			***REMOVED***
		***REMOVED*** else ***REMOVED***
			// No compression is used; disable our decompressor.
			as.dc = nil
		***REMOVED***
		// Only initialize this state once per stream.
		as.decompSet = true
	***REMOVED***
	err = recv(as.p, as.codec, as.s, as.dc, m, *as.callInfo.maxReceiveMessageSize, nil, as.decomp)
	if err != nil ***REMOVED***
		if err == io.EOF ***REMOVED***
			if statusErr := as.s.Status().Err(); statusErr != nil ***REMOVED***
				return statusErr
			***REMOVED***
			return io.EOF // indicates successful end of stream.
		***REMOVED***
		return toRPCErr(err)
	***REMOVED***

	if channelz.IsOn() ***REMOVED***
		as.t.IncrMsgRecv()
	***REMOVED***
	if as.desc.ServerStreams ***REMOVED***
		// Subsequent messages should be received by subsequent RecvMsg calls.
		return nil
	***REMOVED***

	// Special handling for non-server-stream rpcs.
	// This recv expects EOF or errors, so we don't collect inPayload.
	err = recv(as.p, as.codec, as.s, as.dc, m, *as.callInfo.maxReceiveMessageSize, nil, as.decomp)
	if err == nil ***REMOVED***
		return toRPCErr(errors.New("grpc: client streaming protocol violation: get <nil>, want <EOF>"))
	***REMOVED***
	if err == io.EOF ***REMOVED***
		return as.s.Status().Err() // non-server streaming Recv returns nil on success
	***REMOVED***
	return toRPCErr(err)
***REMOVED***

func (as *addrConnStream) finish(err error) ***REMOVED***
	as.mu.Lock()
	if as.finished ***REMOVED***
		as.mu.Unlock()
		return
	***REMOVED***
	as.finished = true
	if err == io.EOF ***REMOVED***
		// Ending a stream with EOF indicates a success.
		err = nil
	***REMOVED***
	if as.s != nil ***REMOVED***
		as.t.CloseStream(as.s, err)
	***REMOVED***

	if err != nil ***REMOVED***
		as.ac.incrCallsFailed()
	***REMOVED*** else ***REMOVED***
		as.ac.incrCallsSucceeded()
	***REMOVED***
	as.cancel()
	as.mu.Unlock()
***REMOVED***

// ServerStream defines the server-side behavior of a streaming RPC.
//
// All errors returned from ServerStream methods are compatible with the
// status package.
type ServerStream interface ***REMOVED***
	// SetHeader sets the header metadata. It may be called multiple times.
	// When call multiple times, all the provided metadata will be merged.
	// All the metadata will be sent out when one of the following happens:
	//  - ServerStream.SendHeader() is called;
	//  - The first response is sent out;
	//  - An RPC status is sent out (error or success).
	SetHeader(metadata.MD) error
	// SendHeader sends the header metadata.
	// The provided md and headers set by SetHeader() will be sent.
	// It fails if called multiple times.
	SendHeader(metadata.MD) error
	// SetTrailer sets the trailer metadata which will be sent with the RPC status.
	// When called more than once, all the provided metadata will be merged.
	SetTrailer(metadata.MD)
	// Context returns the context for this stream.
	Context() context.Context
	// SendMsg sends a message. On error, SendMsg aborts the stream and the
	// error is returned directly.
	//
	// SendMsg blocks until:
	//   - There is sufficient flow control to schedule m with the transport, or
	//   - The stream is done, or
	//   - The stream breaks.
	//
	// SendMsg does not wait until the message is received by the client. An
	// untimely stream closure may result in lost messages.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not safe
	// to call SendMsg on the same stream in different goroutines.
	SendMsg(m interface***REMOVED******REMOVED***) error
	// RecvMsg blocks until it receives a message into m or the stream is
	// done. It returns io.EOF when the client has performed a CloseSend. On
	// any non-EOF error, the stream is aborted and the error contains the
	// RPC status.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not
	// safe to call RecvMsg on the same stream in different goroutines.
	RecvMsg(m interface***REMOVED******REMOVED***) error
***REMOVED***

// serverStream implements a server side Stream.
type serverStream struct ***REMOVED***
	ctx   context.Context
	t     transport.ServerTransport
	s     *transport.Stream
	p     *parser
	codec baseCodec

	cp     Compressor
	dc     Decompressor
	comp   encoding.Compressor
	decomp encoding.Compressor

	maxReceiveMessageSize int
	maxSendMessageSize    int
	trInfo                *traceInfo

	statsHandler stats.Handler

	binlog *binarylog.MethodLogger
	// serverHeaderBinlogged indicates whether server header has been logged. It
	// will happen when one of the following two happens: stream.SendHeader(),
	// stream.Send().
	//
	// It's only checked in send and sendHeader, doesn't need to be
	// synchronized.
	serverHeaderBinlogged bool

	mu sync.Mutex // protects trInfo.tr after the service handler runs.
***REMOVED***

func (ss *serverStream) Context() context.Context ***REMOVED***
	return ss.ctx
***REMOVED***

func (ss *serverStream) SetHeader(md metadata.MD) error ***REMOVED***
	if md.Len() == 0 ***REMOVED***
		return nil
	***REMOVED***
	return ss.s.SetHeader(md)
***REMOVED***

func (ss *serverStream) SendHeader(md metadata.MD) error ***REMOVED***
	err := ss.t.WriteHeader(ss.s, md)
	if ss.binlog != nil && !ss.serverHeaderBinlogged ***REMOVED***
		h, _ := ss.s.Header()
		ss.binlog.Log(&binarylog.ServerHeader***REMOVED***
			Header: h,
		***REMOVED***)
		ss.serverHeaderBinlogged = true
	***REMOVED***
	return err
***REMOVED***

func (ss *serverStream) SetTrailer(md metadata.MD) ***REMOVED***
	if md.Len() == 0 ***REMOVED***
		return
	***REMOVED***
	ss.s.SetTrailer(md)
***REMOVED***

func (ss *serverStream) SendMsg(m interface***REMOVED******REMOVED***) (err error) ***REMOVED***
	defer func() ***REMOVED***
		if ss.trInfo != nil ***REMOVED***
			ss.mu.Lock()
			if ss.trInfo.tr != nil ***REMOVED***
				if err == nil ***REMOVED***
					ss.trInfo.tr.LazyLog(&payload***REMOVED***sent: true, msg: m***REMOVED***, true)
				***REMOVED*** else ***REMOVED***
					ss.trInfo.tr.LazyLog(&fmtStringer***REMOVED***"%v", []interface***REMOVED******REMOVED******REMOVED***err***REMOVED******REMOVED***, true)
					ss.trInfo.tr.SetError()
				***REMOVED***
			***REMOVED***
			ss.mu.Unlock()
		***REMOVED***
		if err != nil && err != io.EOF ***REMOVED***
			st, _ := status.FromError(toRPCErr(err))
			ss.t.WriteStatus(ss.s, st)
			// Non-user specified status was sent out. This should be an error
			// case (as a server side Cancel maybe).
			//
			// This is not handled specifically now. User will return a final
			// status from the service handler, we will log that error instead.
			// This behavior is similar to an interceptor.
		***REMOVED***
		if channelz.IsOn() && err == nil ***REMOVED***
			ss.t.IncrMsgSent()
		***REMOVED***
	***REMOVED***()

	// load hdr, payload, data
	hdr, payload, data, err := prepareMsg(m, ss.codec, ss.cp, ss.comp)
	if err != nil ***REMOVED***
		return err
	***REMOVED***

	// TODO(dfawley): should we be checking len(data) instead?
	if len(payload) > ss.maxSendMessageSize ***REMOVED***
		return status.Errorf(codes.ResourceExhausted, "trying to send message larger than max (%d vs. %d)", len(payload), ss.maxSendMessageSize)
	***REMOVED***
	if err := ss.t.Write(ss.s, hdr, payload, &transport.Options***REMOVED***Last: false***REMOVED***); err != nil ***REMOVED***
		return toRPCErr(err)
	***REMOVED***
	if ss.binlog != nil ***REMOVED***
		if !ss.serverHeaderBinlogged ***REMOVED***
			h, _ := ss.s.Header()
			ss.binlog.Log(&binarylog.ServerHeader***REMOVED***
				Header: h,
			***REMOVED***)
			ss.serverHeaderBinlogged = true
		***REMOVED***
		ss.binlog.Log(&binarylog.ServerMessage***REMOVED***
			Message: data,
		***REMOVED***)
	***REMOVED***
	if ss.statsHandler != nil ***REMOVED***
		ss.statsHandler.HandleRPC(ss.s.Context(), outPayload(false, m, data, payload, time.Now()))
	***REMOVED***
	return nil
***REMOVED***

func (ss *serverStream) RecvMsg(m interface***REMOVED******REMOVED***) (err error) ***REMOVED***
	defer func() ***REMOVED***
		if ss.trInfo != nil ***REMOVED***
			ss.mu.Lock()
			if ss.trInfo.tr != nil ***REMOVED***
				if err == nil ***REMOVED***
					ss.trInfo.tr.LazyLog(&payload***REMOVED***sent: false, msg: m***REMOVED***, true)
				***REMOVED*** else if err != io.EOF ***REMOVED***
					ss.trInfo.tr.LazyLog(&fmtStringer***REMOVED***"%v", []interface***REMOVED******REMOVED******REMOVED***err***REMOVED******REMOVED***, true)
					ss.trInfo.tr.SetError()
				***REMOVED***
			***REMOVED***
			ss.mu.Unlock()
		***REMOVED***
		if err != nil && err != io.EOF ***REMOVED***
			st, _ := status.FromError(toRPCErr(err))
			ss.t.WriteStatus(ss.s, st)
			// Non-user specified status was sent out. This should be an error
			// case (as a server side Cancel maybe).
			//
			// This is not handled specifically now. User will return a final
			// status from the service handler, we will log that error instead.
			// This behavior is similar to an interceptor.
		***REMOVED***
		if channelz.IsOn() && err == nil ***REMOVED***
			ss.t.IncrMsgRecv()
		***REMOVED***
	***REMOVED***()
	var payInfo *payloadInfo
	if ss.statsHandler != nil || ss.binlog != nil ***REMOVED***
		payInfo = &payloadInfo***REMOVED******REMOVED***
	***REMOVED***
	if err := recv(ss.p, ss.codec, ss.s, ss.dc, m, ss.maxReceiveMessageSize, payInfo, ss.decomp); err != nil ***REMOVED***
		if err == io.EOF ***REMOVED***
			if ss.binlog != nil ***REMOVED***
				ss.binlog.Log(&binarylog.ClientHalfClose***REMOVED******REMOVED***)
			***REMOVED***
			return err
		***REMOVED***
		if err == io.ErrUnexpectedEOF ***REMOVED***
			err = status.Errorf(codes.Internal, io.ErrUnexpectedEOF.Error())
		***REMOVED***
		return toRPCErr(err)
	***REMOVED***
	if ss.statsHandler != nil ***REMOVED***
		ss.statsHandler.HandleRPC(ss.s.Context(), &stats.InPayload***REMOVED***
			RecvTime: time.Now(),
			Payload:  m,
			// TODO truncate large payload.
			Data:       payInfo.uncompressedBytes,
			WireLength: payInfo.wireLength + headerLen,
			Length:     len(payInfo.uncompressedBytes),
		***REMOVED***)
	***REMOVED***
	if ss.binlog != nil ***REMOVED***
		ss.binlog.Log(&binarylog.ClientMessage***REMOVED***
			Message: payInfo.uncompressedBytes,
		***REMOVED***)
	***REMOVED***
	return nil
***REMOVED***

// MethodFromServerStream returns the method string for the input stream.
// The returned string is in the format of "/service/method".
func MethodFromServerStream(stream ServerStream) (string, bool) ***REMOVED***
	return Method(stream.Context())
***REMOVED***

// prepareMsg returns the hdr, payload and data
// using the compressors passed or using the
// passed preparedmsg
func prepareMsg(m interface***REMOVED******REMOVED***, codec baseCodec, cp Compressor, comp encoding.Compressor) (hdr, payload, data []byte, err error) ***REMOVED***
	if preparedMsg, ok := m.(*PreparedMsg); ok ***REMOVED***
		return preparedMsg.hdr, preparedMsg.payload, preparedMsg.encodedData, nil
	***REMOVED***
	// The input interface is not a prepared msg.
	// Marshal and Compress the data at this point
	data, err = encode(codec, m)
	if err != nil ***REMOVED***
		return nil, nil, nil, err
	***REMOVED***
	compData, err := compress(data, cp, comp)
	if err != nil ***REMOVED***
		return nil, nil, nil, err
	***REMOVED***
	hdr, payload = msgHeader(data, compData)
	return hdr, payload, data, nil
***REMOVED***
